<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rah: RAH_NAMESPACE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rah
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">RAH_NAMESPACE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_r_a_h___n_a_m_e_s_p_a_c_e_1_1view"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e_1_1view.html">view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__facade.html">iterator_facade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1bidirectional__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1forward__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::forward_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1random__access__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1pipeable.html">pipeable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a46705781d6869d5151141f871ced1e9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46705781d6869d5151141f871ced1e9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a46705781d6869d5151141f871ced1e9c">range_begin_type_t</a> = decltype(std::begin(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a46705781d6869d5151141f871ced1e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeb8c12d454f4cc70bf80766871d3b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadeb8c12d454f4cc70bf80766871d3b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aadeb8c12d454f4cc70bf80766871d3b2">range_end_type_t</a> = decltype(std::end(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:aadeb8c12d454f4cc70bf80766871d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe6e664ee98ab43f993f56d9b9ff78c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbe6e664ee98ab43f993f56d9b9ff78c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#acbe6e664ee98ab43f993f56d9b9ff78c">range_ref_type_t</a> = decltype(*std::begin(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:acbe6e664ee98ab43f993f56d9b9ff78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18265be3353813dd9328818516e0db60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18265be3353813dd9328818516e0db60"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a18265be3353813dd9328818516e0db60">range_value_type_t</a> = std::remove_reference_t&lt; <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#acbe6e664ee98ab43f993f56d9b9ff78c">range_ref_type_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a18265be3353813dd9328818516e0db60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ebb55d3cc13168a7da1ccdf509dc6e"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ad5ebb55d3cc13168a7da1ccdf509dc6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5ebb55d3cc13168a7da1ccdf509dc6e">range_iter_categ_t</a> = typename std::iterator_traits&lt; <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a46705781d6869d5151141f871ced1e9c">range_begin_type_t</a>&lt; R &gt; &gt;::iterator_category</td></tr>
<tr class="separator:ad5ebb55d3cc13168a7da1ccdf509dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23011f56a88d50b186adcd2ba96daecd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23011f56a88d50b186adcd2ba96daecd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a> ()</td></tr>
<tr class="separator:a23011f56a88d50b186adcd2ba96daecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9663e7b91642eed0f6bbcacace9118fe"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a9663e7b91642eed0f6bbcacace9118fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a9663e7b91642eed0f6bbcacace9118fe">make_iterator_range</a> (I b, I e)</td></tr>
<tr class="separator:a9663e7b91642eed0f6bbcacace9118fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db588db40ca52dae948613525ac1b4"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a40db588db40ca52dae948613525ac1b4"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a40db588db40ca52dae948613525ac1b4">begin</a> (<a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="separator:a40db588db40ca52dae948613525ac1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f90a809a5221569377c400175a20bf"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ad5f90a809a5221569377c400175a20bf"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5f90a809a5221569377c400175a20bf">end</a> (<a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="separator:ad5f90a809a5221569377c400175a20bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226e473d9053e6dbcdc5fa4d135b7abe"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a226e473d9053e6dbcdc5fa4d135b7abe"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a226e473d9053e6dbcdc5fa4d135b7abe">begin</a> (<a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="separator:a226e473d9053e6dbcdc5fa4d135b7abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27794282c76c7027fac8b956ffd0a2a"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ac27794282c76c7027fac8b956ffd0a2a"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ac27794282c76c7027fac8b956ffd0a2a">end</a> (<a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="separator:ac27794282c76c7027fac8b956ffd0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8277a9bf35f4c28d8be20d1cd4bc1b"><td class="memTemplParams" colspan="2">template&lt;typename MakeRange &gt; </td></tr>
<tr class="memitem:a4f8277a9bf35f4c28d8be20d1cd4bc1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a4f8277a9bf35f4c28d8be20d1cd4bc1b">make_pipeable</a> (MakeRange &amp;&amp;make_range)</td></tr>
<tr class="separator:a4f8277a9bf35f4c28d8be20d1cd4bc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70ad03bbe29c97324a4ffe14f7990fc"><td class="memTemplParams" colspan="2">template&lt;typename R , typename MakeRange &gt; </td></tr>
<tr class="memitem:ac70ad03bbe29c97324a4ffe14f7990fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ac70ad03bbe29c97324a4ffe14f7990fc">operator|</a> (R &amp;&amp;range, <a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;adapter)</td></tr>
<tr class="separator:ac70ad03bbe29c97324a4ffe14f7990fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98499dc6e9855d07b986c71618b6fd84"><td class="memTemplParams" colspan="2">template&lt;typename RI , typename RO , typename F &gt; </td></tr>
<tr class="memitem:a98499dc6e9855d07b986c71618b6fd84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a98499dc6e9855d07b986c71618b6fd84">transform</a> (RI &amp;&amp;rangeIn, RO &amp;&amp;rangeOut, F &amp;&amp;unary_op)</td></tr>
<tr class="memdesc:a98499dc6e9855d07b986c71618b6fd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut.  <a href="#a98499dc6e9855d07b986c71618b6fd84">More...</a><br /></td></tr>
<tr class="separator:a98499dc6e9855d07b986c71618b6fd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27e19739b326c99cc09b3f5959fca93"><td class="memTemplParams" colspan="2">template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </td></tr>
<tr class="memitem:ae27e19739b326c99cc09b3f5959fca93"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ae27e19739b326c99cc09b3f5959fca93">transform</a> (RI1 &amp;&amp;rangeIn1, RI2 &amp;&amp;rangeIn2, RO &amp;&amp;rangeOut, F &amp;&amp;binary_op)</td></tr>
<tr class="memdesc:ae27e19739b326c99cc09b3f5959fca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary operation binary_op is applied to pairs of elements from two ranges.  <a href="#ae27e19739b326c99cc09b3f5959fca93">More...</a><br /></td></tr>
<tr class="separator:ae27e19739b326c99cc09b3f5959fca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f989f80f1fe3bf2eac4106e5d6fe35"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename F &gt; </td></tr>
<tr class="memitem:ae1f989f80f1fe3bf2eac4106e5d6fe35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ae1f989f80f1fe3bf2eac4106e5d6fe35">reduce</a> (R &amp;&amp;range, I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:ae1f989f80f1fe3bf2eac4106e5d6fe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#ae1f989f80f1fe3bf2eac4106e5d6fe35">More...</a><br /></td></tr>
<tr class="separator:ae1f989f80f1fe3bf2eac4106e5d6fe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5beb1dcde4f4782304a4e3688b1851a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ad5beb1dcde4f4782304a4e3688b1851a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5beb1dcde4f4782304a4e3688b1851a">reduce</a> (I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:ad5beb1dcde4f4782304a4e3688b1851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#ad5beb1dcde4f4782304a4e3688b1851a">More...</a><br /></td></tr>
<tr class="separator:ad5beb1dcde4f4782304a4e3688b1851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b528a9d2905dd9bbfca7076943f3f65"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a1b528a9d2905dd9bbfca7076943f3f65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a1b528a9d2905dd9bbfca7076943f3f65">any_of</a> (R &amp;&amp;range, F &amp;&amp;pred)</td></tr>
<tr class="memdesc:a1b528a9d2905dd9bbfca7076943f3f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#a1b528a9d2905dd9bbfca7076943f3f65">More...</a><br /></td></tr>
<tr class="separator:a1b528a9d2905dd9bbfca7076943f3f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8ad5a0d01fd603725fbc2c7b3fc4b"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:afcb8ad5a0d01fd603725fbc2c7b3fc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#afcb8ad5a0d01fd603725fbc2c7b3fc4b">any_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:afcb8ad5a0d01fd603725fbc2c7b3fc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#afcb8ad5a0d01fd603725fbc2c7b3fc4b">More...</a><br /></td></tr>
<tr class="separator:afcb8ad5a0d01fd603725fbc2c7b3fc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c662eceec62042b028b7174ae6106"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:aec4c662eceec62042b028b7174ae6106"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aec4c662eceec62042b028b7174ae6106">all_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aec4c662eceec62042b028b7174ae6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#aec4c662eceec62042b028b7174ae6106">More...</a><br /></td></tr>
<tr class="separator:aec4c662eceec62042b028b7174ae6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fbd8db9d61d38ce1f5511d3851250"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a227fbd8db9d61d38ce1f5511d3851250"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a227fbd8db9d61d38ce1f5511d3851250">all_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a227fbd8db9d61d38ce1f5511d3851250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#a227fbd8db9d61d38ce1f5511d3851250">More...</a><br /></td></tr>
<tr class="separator:a227fbd8db9d61d38ce1f5511d3851250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7449384fc236ed8a79ecfd52bd334c2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:ad7449384fc236ed8a79ecfd52bd334c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad7449384fc236ed8a79ecfd52bd334c2">none_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:ad7449384fc236ed8a79ecfd52bd334c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#ad7449384fc236ed8a79ecfd52bd334c2">More...</a><br /></td></tr>
<tr class="separator:ad7449384fc236ed8a79ecfd52bd334c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7425c09d4149cbe477e18a93576d84bd"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a7425c09d4149cbe477e18a93576d84bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a7425c09d4149cbe477e18a93576d84bd">none_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a7425c09d4149cbe477e18a93576d84bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#a7425c09d4149cbe477e18a93576d84bd">More...</a><br /></td></tr>
<tr class="separator:a7425c09d4149cbe477e18a93576d84bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7b2627a4cd1c0877ea39d0b1bae608"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a7c7b2627a4cd1c0877ea39d0b1bae608"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a7c7b2627a4cd1c0877ea39d0b1bae608">count</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a7c7b2627a4cd1c0877ea39d0b1bae608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#a7c7b2627a4cd1c0877ea39d0b1bae608">More...</a><br /></td></tr>
<tr class="separator:a7c7b2627a4cd1c0877ea39d0b1bae608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85f193e93d3512d1cb2d62fbbe02d8c"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae85f193e93d3512d1cb2d62fbbe02d8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ae85f193e93d3512d1cb2d62fbbe02d8c">count</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:ae85f193e93d3512d1cb2d62fbbe02d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#ae85f193e93d3512d1cb2d62fbbe02d8c">More...</a><br /></td></tr>
<tr class="separator:ae85f193e93d3512d1cb2d62fbbe02d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac05baef6d97b6f141ff91efc955f76"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:aaac05baef6d97b6f141ff91efc955f76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaac05baef6d97b6f141ff91efc955f76">count_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aaac05baef6d97b6f141ff91efc955f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#aaac05baef6d97b6f141ff91efc955f76">More...</a><br /></td></tr>
<tr class="separator:aaac05baef6d97b6f141ff91efc955f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb881e74f4e82fb751ac6fca7859f36"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a8bb881e74f4e82fb751ac6fca7859f36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a8bb881e74f4e82fb751ac6fca7859f36">count_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a8bb881e74f4e82fb751ac6fca7859f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#a8bb881e74f4e82fb751ac6fca7859f36">More...</a><br /></td></tr>
<tr class="separator:a8bb881e74f4e82fb751ac6fca7859f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81222de7a8a2ef5d8dfb40733190a573"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a81222de7a8a2ef5d8dfb40733190a573"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a81222de7a8a2ef5d8dfb40733190a573">for_each</a> (R &amp;&amp;range, F &amp;&amp;func)</td></tr>
<tr class="memdesc:a81222de7a8a2ef5d8dfb40733190a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#a81222de7a8a2ef5d8dfb40733190a573">More...</a><br /></td></tr>
<tr class="separator:a81222de7a8a2ef5d8dfb40733190a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6981e8b11a89660367386b77cb9e98e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad6981e8b11a89660367386b77cb9e98e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad6981e8b11a89660367386b77cb9e98e">for_each</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:ad6981e8b11a89660367386b77cb9e98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#ad6981e8b11a89660367386b77cb9e98e">More...</a><br /></td></tr>
<tr class="separator:ad6981e8b11a89660367386b77cb9e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeda276f5ef0a84c8ab43dc6ab213457"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R &gt; </td></tr>
<tr class="memitem:aaeda276f5ef0a84c8ab43dc6ab213457"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaeda276f5ef0a84c8ab43dc6ab213457">to_container</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:aaeda276f5ef0a84c8ab43dc6ab213457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#aaeda276f5ef0a84c8ab43dc6ab213457">More...</a><br /></td></tr>
<tr class="separator:aaeda276f5ef0a84c8ab43dc6ab213457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c872e0258890901febfd0ed8caabd"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a1f7c872e0258890901febfd0ed8caabd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a1f7c872e0258890901febfd0ed8caabd">to_container</a> ()</td></tr>
<tr class="memdesc:a1f7c872e0258890901febfd0ed8caabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#a1f7c872e0258890901febfd0ed8caabd">More...</a><br /></td></tr>
<tr class="separator:a1f7c872e0258890901febfd0ed8caabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267247366bb3abea3e383e7dd3c5f2d7"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a267247366bb3abea3e383e7dd3c5f2d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a267247366bb3abea3e383e7dd3c5f2d7">mismatch</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a267247366bb3abea3e383e7dd3c5f2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first position where two ranges differ.  <a href="#a267247366bb3abea3e383e7dd3c5f2d7">More...</a><br /></td></tr>
<tr class="separator:a267247366bb3abea3e383e7dd3c5f2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b865606b3c78c61a732f4fef4e0576b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a4b865606b3c78c61a732f4fef4e0576b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a4b865606b3c78c61a732f4fef4e0576b">find</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a4b865606b3c78c61a732f4fef4e0576b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a4b865606b3c78c61a732f4fef4e0576b">More...</a><br /></td></tr>
<tr class="separator:a4b865606b3c78c61a732f4fef4e0576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fc53c7921b52d24f79ac55711673b3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a95fc53c7921b52d24f79ac55711673b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a95fc53c7921b52d24f79ac55711673b3">find</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a95fc53c7921b52d24f79ac55711673b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a95fc53c7921b52d24f79ac55711673b3">More...</a><br /></td></tr>
<tr class="separator:a95fc53c7921b52d24f79ac55711673b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f32b471719285bd12cea80d2611d4e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a17f32b471719285bd12cea80d2611d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a17f32b471719285bd12cea80d2611d4e">find_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a17f32b471719285bd12cea80d2611d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#a17f32b471719285bd12cea80d2611d4e">More...</a><br /></td></tr>
<tr class="separator:a17f32b471719285bd12cea80d2611d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e890baf36c953a1839b7c71c069cb50"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a7e890baf36c953a1839b7c71c069cb50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a7e890baf36c953a1839b7c71c069cb50">find_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a7e890baf36c953a1839b7c71c069cb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#a7e890baf36c953a1839b7c71c069cb50">More...</a><br /></td></tr>
<tr class="separator:a7e890baf36c953a1839b7c71c069cb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af151731e0c4d4cae20f1c3c3ea92cd1b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:af151731e0c4d4cae20f1c3c3ea92cd1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#af151731e0c4d4cae20f1c3c3ea92cd1b">find_if_not</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:af151731e0c4d4cae20f1c3c3ea92cd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#af151731e0c4d4cae20f1c3c3ea92cd1b">More...</a><br /></td></tr>
<tr class="separator:af151731e0c4d4cae20f1c3c3ea92cd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583e285f755eb8a41e23446718e14d18"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a583e285f755eb8a41e23446718e14d18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a583e285f755eb8a41e23446718e14d18">find_if_not</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a583e285f755eb8a41e23446718e14d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#a583e285f755eb8a41e23446718e14d18">More...</a><br /></td></tr>
<tr class="separator:a583e285f755eb8a41e23446718e14d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9741e7a14ce65a685c365223a6dd55c7"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a9741e7a14ce65a685c365223a6dd55c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a9741e7a14ce65a685c365223a6dd55c7">size</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a9741e7a14ce65a685c365223a6dd55c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#a9741e7a14ce65a685c365223a6dd55c7">More...</a><br /></td></tr>
<tr class="separator:a9741e7a14ce65a685c365223a6dd55c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f0d40418ca1878f19bafdb3d823f27"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a70f0d40418ca1878f19bafdb3d823f27">size</a> ()</td></tr>
<tr class="memdesc:a70f0d40418ca1878f19bafdb3d823f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#a70f0d40418ca1878f19bafdb3d823f27">More...</a><br /></td></tr>
<tr class="separator:a70f0d40418ca1878f19bafdb3d823f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecf925d702d4b5f9c35c7094b0a7436"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a0ecf925d702d4b5f9c35c7094b0a7436"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a0ecf925d702d4b5f9c35c7094b0a7436">equal</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a0ecf925d702d4b5f9c35c7094b0a7436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two sets of elements are the same.  <a href="#a0ecf925d702d4b5f9c35c7094b0a7436">More...</a><br /></td></tr>
<tr class="separator:a0ecf925d702d4b5f9c35c7094b0a7436"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a46705781d6869d5151141f871ced1e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46705781d6869d5151141f871ced1e9c">&#9670;&nbsp;</a></span>range_begin_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a46705781d6869d5151141f871ced1e9c">RAH_NAMESPACE::range_begin_type_t</a> = typedef decltype(std::begin(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadeb8c12d454f4cc70bf80766871d3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeb8c12d454f4cc70bf80766871d3b2">&#9670;&nbsp;</a></span>range_end_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aadeb8c12d454f4cc70bf80766871d3b2">RAH_NAMESPACE::range_end_type_t</a> = typedef decltype(std::end(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ebb55d3cc13168a7da1ccdf509dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ebb55d3cc13168a7da1ccdf509dc6e">&#9670;&nbsp;</a></span>range_iter_categ_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5ebb55d3cc13168a7da1ccdf509dc6e">RAH_NAMESPACE::range_iter_categ_t</a> = typedef typename std::iterator_traits&lt;<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a46705781d6869d5151141f871ced1e9c">range_begin_type_t</a>&lt;R&gt; &gt;::iterator_category</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe6e664ee98ab43f993f56d9b9ff78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe6e664ee98ab43f993f56d9b9ff78c">&#9670;&nbsp;</a></span>range_ref_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#acbe6e664ee98ab43f993f56d9b9ff78c">RAH_NAMESPACE::range_ref_type_t</a> = typedef decltype(*std::begin(<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a23011f56a88d50b186adcd2ba96daecd">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18265be3353813dd9328818516e0db60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18265be3353813dd9328818516e0db60">&#9670;&nbsp;</a></span>range_value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a18265be3353813dd9328818516e0db60">RAH_NAMESPACE::range_value_type_t</a> = typedef std::remove_reference_t&lt;<a class="el" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#acbe6e664ee98ab43f993f56d9b9ff78c">range_ref_type_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aec4c662eceec62042b028b7174ae6106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4c662eceec62042b028b7174ae6106">&#9670;&nbsp;</a></span>all_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::all_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aec4c662eceec62042b028b7174ae6106">rah::all_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 4, 4 }, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="a227fbd8db9d61d38ce1f5511d3851250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227fbd8db9d61d38ce1f5511d3851250">&#9670;&nbsp;</a></span>all_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::all_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 3, 4 } </div><div class="line">        | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aec4c662eceec62042b028b7174ae6106">rah::all_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">    ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a1b528a9d2905dd9bbfca7076943f3f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b528a9d2905dd9bbfca7076943f3f65">&#9670;&nbsp;</a></span>any_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::any_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a1b528a9d2905dd9bbfca7076943f3f65">rah::any_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 3, 0, 1, 3, 4, 6 }, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="afcb8ad5a0d01fd603725fbc2c7b3fc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb8ad5a0d01fd603725fbc2c7b3fc4b">&#9670;&nbsp;</a></span>any_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::any_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{0, 1, 2, 3, 4, 6}</div><div class="line">        | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a1b528a9d2905dd9bbfca7076943f3f65">rah::any_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">    ));</div></div><!-- fragment -->
</div>
</div>
<a id="a40db588db40ca52dae948613525ac1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40db588db40ca52dae948613525ac1b4">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I RAH_NAMESPACE::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a226e473d9053e6dbcdc5fa4d135b7abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226e473d9053e6dbcdc5fa4d135b7abe">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I RAH_NAMESPACE::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7b2627a4cd1c0877ea39d0b1bae608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7b2627a4cd1c0877ea39d0b1bae608">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::count </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a7c7b2627a4cd1c0877ea39d0b1bae608">rah::count</a>(std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 }, 3) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="ae85f193e93d3512d1cb2d62fbbe02d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85f193e93d3512d1cb2d62fbbe02d8c">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::count </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a7c7b2627a4cd1c0877ea39d0b1bae608">rah::count</a>(4)) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="aaac05baef6d97b6f141ff91efc955f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac05baef6d97b6f141ff91efc955f76">&#9670;&nbsp;</a></span>count_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::count_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaac05baef6d97b6f141ff91efc955f76">rah::count_if</a>(il&lt;int&gt;{ 4, 4, 4, 3 }, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; }) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a8bb881e74f4e82fb751ac6fca7859f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb881e74f4e82fb751ac6fca7859f36">&#9670;&nbsp;</a></span>count_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::count_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<div class="fragment"><div class="line">    assert((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaac05baef6d97b6f141ff91efc955f76">rah::count_if</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="ad5f90a809a5221569377c400175a20bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f90a809a5221569377c400175a20bf">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I RAH_NAMESPACE::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac27794282c76c7027fac8b956ffd0a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27794282c76c7027fac8b956ffd0a2a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I RAH_NAMESPACE::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ecf925d702d4b5f9c35c7094b0a7436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecf925d702d4b5f9c35c7094b0a7436">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::equal </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two sets of elements are the same. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in3{ 11, 12, 13 };</div><div class="line">        assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a0ecf925d702d4b5f9c35c7094b0a7436">rah::equal</a>(in1, in2));</div><div class="line">        assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a0ecf925d702d4b5f9c35c7094b0a7436">rah::equal</a>(in1, in3) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a23011f56a88d50b186adcd2ba96daecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23011f56a88d50b186adcd2ba96daecd">&#9670;&nbsp;</a></span>fake()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; RAH_NAMESPACE::fake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b865606b3c78c61a732f4fef4e0576b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b865606b3c78c61a732f4fef4e0576b">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a4b865606b3c78c61a732f4fef4e0576b">rah::find</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, 3) | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaeda276f5ef0a84c8ab43dc6ab213457">rah::to_container</a>&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({3, 4})</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a95fc53c7921b52d24f79ac55711673b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fc53c7921b52d24f79ac55711673b3">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a4b865606b3c78c61a732f4fef4e0576b">rah::find</a>(3) | rah::to_container&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({ 3, 4 })</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a17f32b471719285bd12cea80d2611d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f32b471719285bd12cea80d2611d4e">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a17f32b471719285bd12cea80d2611d4e">rah::find_if</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; }) | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaeda276f5ef0a84c8ab43dc6ab213457">rah::to_container</a>&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({ 3, 4 })</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a7e890baf36c953a1839b7c71c069cb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e890baf36c953a1839b7c71c069cb50">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a17f32b471719285bd12cea80d2611d4e">rah::find_if</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; }) | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#aaeda276f5ef0a84c8ab43dc6ab213457">rah::to_container</a>&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({ 3, 4 })</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="af151731e0c4d4cae20f1c3c3ea92cd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af151731e0c4d4cae20f1c3c3ea92cd1b">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find_if_not </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#af151731e0c4d4cae20f1c3c3ea92cd1b">rah::find_if_not</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; }) | rah::to_container&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({ 3, 4 })</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a583e285f755eb8a41e23446718e14d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583e285f755eb8a41e23446718e14d18">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::find_if_not </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#af151731e0c4d4cae20f1c3c3ea92cd1b">rah::find_if_not</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; }) | rah::to_container&lt;std::vector&lt;int&gt;&gt;())</div><div class="line">            == std::vector&lt;int&gt;({ 3, 4 })</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a81222de7a8a2ef5d8dfb40733190a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81222de7a8a2ef5d8dfb40733190a573">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RAH_NAMESPACE::for_each </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a81222de7a8a2ef5d8dfb40733190a573">rah::for_each</a>(testFE, [](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        EQUAL_RANGE(testFE, il&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ad6981e8b11a89660367386b77cb9e98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6981e8b11a89660367386b77cb9e98e">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        testFE | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a81222de7a8a2ef5d8dfb40733190a573">rah::for_each</a>([](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        EQUAL_RANGE(testFE, il&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a9663e7b91642eed0f6bbcacace9118fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9663e7b91642eed0f6bbcacace9118fe">&#9670;&nbsp;</a></span>make_iterator_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::make_iterator_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f8277a9bf35f4c28d8be20d1cd4bc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8277a9bf35f4c28d8be20d1cd4bc1b">&#9670;&nbsp;</a></span>make_pipeable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::make_pipeable </td>
          <td>(</td>
          <td class="paramtype">MakeRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>make_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a267247366bb3abea3e383e7dd3c5f2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267247366bb3abea3e383e7dd3c5f2d7">&#9670;&nbsp;</a></span>mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::mismatch </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first position where two ranges differ. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1 = { 1, 2, 3, 4 };</div><div class="line">        std::vector&lt;int&gt; in2 = { 1, 2, 42, 42 };</div><div class="line">        <span class="keyword">auto</span> r1_r2 = <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a267247366bb3abea3e383e7dd3c5f2d7">rah::mismatch</a>(in1, in2);</div><div class="line">        std::vector&lt;int&gt; out1;</div><div class="line">        std::vector&lt;int&gt; out2;</div><div class="line">        std::copy(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a40db588db40ca52dae948613525ac1b4">std::begin</a>(std::get&lt;0&gt;(r1_r2)), <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5f90a809a5221569377c400175a20bf">std::end</a>(std::get&lt;0&gt;(r1_r2)), std::back_inserter(out1));</div><div class="line">        std::copy(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a40db588db40ca52dae948613525ac1b4">std::begin</a>(std::get&lt;1&gt;(r1_r2)), <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad5f90a809a5221569377c400175a20bf">std::end</a>(std::get&lt;1&gt;(r1_r2)), std::back_inserter(out2));</div><div class="line">        assert(out1 == std::vector&lt;int&gt;({ 3, 4 }));</div><div class="line">        assert(out2 == std::vector&lt;int&gt;({ 42, 42 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ad7449384fc236ed8a79ecfd52bd334c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7449384fc236ed8a79ecfd52bd334c2">&#9670;&nbsp;</a></span>none_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::none_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<div class="fragment"><div class="line">    assert((<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad7449384fc236ed8a79ecfd52bd334c2">rah::none_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10}, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">    ));</div></div><!-- fragment -->
</div>
</div>
<a id="a7425c09d4149cbe477e18a93576d84bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7425c09d4149cbe477e18a93576d84bd">&#9670;&nbsp;</a></span>none_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::none_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10, 11} </div><div class="line">        | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ad7449384fc236ed8a79ecfd52bd334c2">rah::none_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">    ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="ac70ad03bbe29c97324a4ffe14f7990fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70ad03bbe29c97324a4ffe14f7990fc">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::operator| </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_a_h___n_a_m_e_s_p_a_c_e_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;&#160;</td>
          <td class="paramname"><em>adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1f989f80f1fe3bf2eac4106e5d6fe35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f989f80f1fe3bf2eac4106e5d6fe35">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::reduce </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ae1f989f80f1fe3bf2eac4106e5d6fe35">rah::reduce</a>(vecIn1, 0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; }) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="ad5beb1dcde4f4782304a4e3688b1851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5beb1dcde4f4782304a4e3688b1851a">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::reduce </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        assert((vecIn1 | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#ae1f989f80f1fe3bf2eac4106e5d6fe35">rah::reduce</a>(0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; })) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="a9741e7a14ce65a685c365223a6dd55c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9741e7a14ce65a685c365223a6dd55c7">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::size </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        assert(<a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a9741e7a14ce65a685c365223a6dd55c7">rah::size</a>(vec3) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a70f0d40418ca1878f19bafdb3d823f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f0d40418ca1878f19bafdb3d823f27">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        assert((vec3 | <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e.html#a9741e7a14ce65a685c365223a6dd55c7">rah::size</a>()) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="aaeda276f5ef0a84c8ab43dc6ab213457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeda276f5ef0a84c8ab43dc6ab213457">&#9670;&nbsp;</a></span>to_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::to_container </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = rah::to_container&lt;std::map&lt;int, char&gt;&gt;(in1);</div><div class="line">        assert(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = rah::to_container&lt;std::vector&lt;int&gt;&gt;(in2);</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a1f7c872e0258890901febfd0ed8caabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7c872e0258890901febfd0ed8caabd">&#9670;&nbsp;</a></span>to_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::to_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = in1 | rah::to_container&lt;std::map&lt;int, char&gt;&gt;();</div><div class="line">        assert(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = in2 | rah::to_container&lt;std::vector&lt;int&gt;&gt;();</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a98499dc6e9855d07b986c71618b6fd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98499dc6e9855d07b986c71618b6fd84">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::transform </td>
          <td>(</td>
          <td class="paramtype">RI &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecOut{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e_1_1view.html#afc88512dbbf36e723e366e7e9777b4ba">rah::transform</a>(vecIn1, vecOut, [](<span class="keywordtype">int</span> a) {<span class="keywordflow">return</span> a + 1; });</div><div class="line">        assert(vecOut == std::vector&lt;int&gt;({ 1, 2, 3, 4 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ae27e19739b326c99cc09b3f5959fca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27e19739b326c99cc09b3f5959fca93">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto RAH_NAMESPACE::transform </td>
          <td>(</td>
          <td class="paramtype">RI1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RI2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary operation binary_op is applied to pairs of elements from two ranges. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecIn2{ 4, 3, 2, 1 };</div><div class="line">        std::vector&lt;int&gt; vecOut{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespace_r_a_h___n_a_m_e_s_p_a_c_e_1_1view.html#afc88512dbbf36e723e366e7e9777b4ba">rah::transform</a>(vecIn1, vecIn2, vecOut, [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {<span class="keywordflow">return</span> a + b; });</div><div class="line">        assert(vecOut == std::vector&lt;int&gt;({ 4, 4, 4, 4 }));</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
