<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rah: rah Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rah
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rah Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerah_1_1action"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah_1_1action.html">action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerah_1_1view"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah_1_1view.html">view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1back__insert__iterator.html">back_insert_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1is__equal.html">is_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the '==' operator on two values of any type.  <a href="structrah_1_1is__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1is__lesser.html">is_lesser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the '&lt;' operator on two values of any type.  <a href="structrah_1_1is__lesser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1is__range.html">is_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1is__range_3_01_r_00_01decltype_07begin_07fake_3_01_r_01_4_07_08_08_00_01end_07fake_cf1a9a1e2579209cb82001bc9eda23c1.html">is_range&lt; R, decltype(begin(fake&lt; R &gt;()), end(fake&lt; R &gt;()), 0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade.html">iterator_facade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make an iterator.  <a href="structrah_1_1iterator__facade.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_01_1_1bidirectional__iterator__tag_01_4.html">iterator_facade&lt; I, R, std ::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_01_1_1forward__iterator__tag_01_4.html">iterator_facade&lt; I, R, std ::forward_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_01_1_1output__iterator__tag_01_4.html">iterator_facade&lt; I, R, std ::output_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_01_1_1random__access__iterator__tag_01_4.html">iterator_facade&lt; I, R, std ::random_access_iterator_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1bidirectional__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a bidirectional iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1bidirectional__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1forward__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::forward_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a forward_iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1forward__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1output__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::output_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make an appendable range.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1output__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1random__access__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a random access iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1random__access__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1pipeable.html">pipeable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow to call a custom function when called whith the 'pipe' syntax on a range.  <a href="structrah_1_1pipeable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1stream__inserter__iterator.html">stream_inserter_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a> = decltype(<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9657e24ae477f4482225b133fe286b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9657e24ae477f4482225b133fe286b65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a9657e24ae477f4482225b133fe286b65">range_end_type_t</a> = decltype(<a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a9657e24ae477f4482225b133fe286b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6622426bea22e9509614fe4c574ebeca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6622426bea22e9509614fe4c574ebeca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a> = decltype(*<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a6622426bea22e9509614fe4c574ebeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0c45ea6e732dc2668edfd0e4f8fccf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c0c45ea6e732dc2668edfd0e4f8fccf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a0c0c45ea6e732dc2668edfd0e4f8fccf">range_value_type_t</a> = std ::remove_reference_t&lt; <a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a0c0c45ea6e732dc2668edfd0e4f8fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdcceefd4c7ad3abffb96560d24517d"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a7cdcceefd4c7ad3abffb96560d24517d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7cdcceefd4c7ad3abffb96560d24517d">range_iter_categ_t</a> = typename std ::iterator_traits&lt; <a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a>&lt; R &gt; &gt;::iterator_category</td></tr>
<tr class="separator:a7cdcceefd4c7ad3abffb96560d24517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11785bbdf970efa1bc57fc14993b77bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11785bbdf970efa1bc57fc14993b77bf"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a> ()</td></tr>
<tr class="memdesc:a11785bbdf970efa1bc57fc14993b77bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in decltype to get an instance of a type.  <a href="#a11785bbdf970efa1bc57fc14993b77bf">More...</a><br /></td></tr>
<tr class="separator:a11785bbdf970efa1bc57fc14993b77bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">make_iterator_range</a> (I b, I e)</td></tr>
<tr class="memdesc:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structrah_1_1iterator__range.html">rah::iterator_range</a> with two given iterators.  <a href="#a4e145bfeb8a932058e20fc4cb4e7c206">More...</a><br /></td></tr>
<tr class="separator:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a19e57cc4e0753e93830f247def6d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a2c4a19e57cc4e0753e93830f247def6d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="memdesc:a2c4a19e57cc4e0753e93830f247def6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator of the range.  <a href="#a2c4a19e57cc4e0753e93830f247def6d">More...</a><br /></td></tr>
<tr class="separator:a2c4a19e57cc4e0753e93830f247def6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddd1442cd76b96876e692cdefe7261d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:aaddd1442cd76b96876e692cdefe7261d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="memdesc:aaddd1442cd76b96876e692cdefe7261d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "past the" end iterator of the range.  <a href="#aaddd1442cd76b96876e692cdefe7261d">More...</a><br /></td></tr>
<tr class="separator:aaddd1442cd76b96876e692cdefe7261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e69321e6772651b349cb31467ea3a2"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a14e69321e6772651b349cb31467ea3a2"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a14e69321e6772651b349cb31467ea3a2">begin</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="memdesc:a14e69321e6772651b349cb31467ea3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator of the range.  <a href="#a14e69321e6772651b349cb31467ea3a2">More...</a><br /></td></tr>
<tr class="separator:a14e69321e6772651b349cb31467ea3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31fe80bf81abf3149df010cb265e20"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a6b31fe80bf81abf3149df010cb265e20"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6b31fe80bf81abf3149df010cb265e20">end</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="memdesc:a6b31fe80bf81abf3149df010cb265e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "past the" end iterator of the range.  <a href="#a6b31fe80bf81abf3149df010cb265e20">More...</a><br /></td></tr>
<tr class="separator:a6b31fe80bf81abf3149df010cb265e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b78c4c0af5dd58ce280f02223fb55"><td class="memTemplParams" colspan="2">template&lt;typename MakeRange &gt; </td></tr>
<tr class="memitem:a274b78c4c0af5dd58ce280f02223fb55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a274b78c4c0af5dd58ce280f02223fb55">make_pipeable</a> (MakeRange &amp;&amp;make_range)</td></tr>
<tr class="memdesc:a274b78c4c0af5dd58ce280f02223fb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to create a "pipeable" function (UFCS style in c++)  <a href="#a274b78c4c0af5dd58ce280f02223fb55">More...</a><br /></td></tr>
<tr class="separator:a274b78c4c0af5dd58ce280f02223fb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ae71c44092414b8a22379bc0d3cd34"><td class="memTemplParams" colspan="2">template&lt;typename R , typename MakeRange &gt; </td></tr>
<tr class="memitem:ab1ae71c44092414b8a22379bc0d3cd34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ab1ae71c44092414b8a22379bc0d3cd34">operator|</a> (R &amp;&amp;range, <a class="el" href="structrah_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;adapter) -&gt; decltype(adapter.func(std ::forward&lt; R &gt;(range)))</td></tr>
<tr class="separator:ab1ae71c44092414b8a22379bc0d3cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0698f952bc3c4f1961929bbddb5812fe"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0698f952bc3c4f1961929bbddb5812fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">back_inserter</a> (C &amp;&amp;container)</td></tr>
<tr class="memdesc:a0698f952bc3c4f1961929bbddb5812fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range which insert into the back of the a container.  <a href="#a0698f952bc3c4f1961929bbddb5812fe">More...</a><br /></td></tr>
<tr class="separator:a0698f952bc3c4f1961929bbddb5812fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51feb1497566c28de396f50735fd259b"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a51feb1497566c28de396f50735fd259b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">empty</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a51feb1497566c28de396f50735fd259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the range if empty.  <a href="#a51feb1497566c28de396f50735fd259b">More...</a><br /></td></tr>
<tr class="separator:a51feb1497566c28de396f50735fd259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6ceb90c934b1c4927ab4e08b985ef6c5">empty</a> ()</td></tr>
<tr class="memdesc:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the range if empty.  <a href="#a6ceb90c934b1c4927ab4e08b985ef6c5">More...</a><br /></td></tr>
<tr class="separator:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095c61033422b8ebe6dc2cc214867aca"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a095c61033422b8ebe6dc2cc214867aca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">equal_range</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a095c61033422b8ebe6dc2cc214867aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range.  <a href="#a095c61033422b8ebe6dc2cc214867aca">More...</a><br /></td></tr>
<tr class="separator:a095c61033422b8ebe6dc2cc214867aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa191bbe5b7dbb9b2e7a21a87dbb9a8a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:afa191bbe5b7dbb9b2e7a21a87dbb9a8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#afa191bbe5b7dbb9b2e7a21a87dbb9a8a">equal_range</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:afa191bbe5b7dbb9b2e7a21a87dbb9a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a range containing all elements equivalent to value in the range.  <a href="#afa191bbe5b7dbb9b2e7a21a87dbb9a8a">More...</a><br /></td></tr>
<tr class="separator:afa191bbe5b7dbb9b2e7a21a87dbb9a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eef379d9f3039fd12f43d5220434976"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a5eef379d9f3039fd12f43d5220434976"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">binary_search</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a5eef379d9f3039fd12f43d5220434976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range.  <a href="#a5eef379d9f3039fd12f43d5220434976">More...</a><br /></td></tr>
<tr class="separator:a5eef379d9f3039fd12f43d5220434976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac532c28d2c52c80adf91a7b8829bd6"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a8ac532c28d2c52c80adf91a7b8829bd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a8ac532c28d2c52c80adf91a7b8829bd6">binary_search</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a8ac532c28d2c52c80adf91a7b8829bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an element equivalent to value appears within the range.  <a href="#a8ac532c28d2c52c80adf91a7b8829bd6">More...</a><br /></td></tr>
<tr class="separator:a8ac532c28d2c52c80adf91a7b8829bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memTemplParams" colspan="2">template&lt;typename RI , typename RO , typename F &gt; </td></tr>
<tr class="memitem:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">transform</a> (RI &amp;&amp;rangeIn, RO &amp;&amp;rangeOut, F &amp;&amp;unary_op)</td></tr>
<tr class="memdesc:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut.  <a href="#a7cb27bf7219a7ee4b47cc9da217810a8">More...</a><br /></td></tr>
<tr class="separator:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bac191e66e0d3f3823e0c08382f0418"><td class="memTemplParams" colspan="2">template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </td></tr>
<tr class="memitem:a7bac191e66e0d3f3823e0c08382f0418"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7bac191e66e0d3f3823e0c08382f0418">transform</a> (RI1 &amp;&amp;rangeIn1, RI2 &amp;&amp;rangeIn2, RO &amp;&amp;rangeOut, F &amp;&amp;binary_op)</td></tr>
<tr class="memdesc:a7bac191e66e0d3f3823e0c08382f0418"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary operation binary_op is applied to pairs of elements from two ranges.  <a href="#a7bac191e66e0d3f3823e0c08382f0418">More...</a><br /></td></tr>
<tr class="separator:a7bac191e66e0d3f3823e0c08382f0418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename F &gt; </td></tr>
<tr class="memitem:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">reduce</a> (R &amp;&amp;range, I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#a407b50a4f029e3f2a3cd0ba9142aea84">More...</a><br /></td></tr>
<tr class="separator:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6a6b7b7e3b78bb4bd16372fbb688c152">reduce</a> (I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#a6a6b7b7e3b78bb4bd16372fbb688c152">More...</a><br /></td></tr>
<tr class="separator:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836c57da2bd108c491f3ba96786f6aa4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a836c57da2bd108c491f3ba96786f6aa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">any_of</a> (R &amp;&amp;range, F &amp;&amp;pred)</td></tr>
<tr class="memdesc:a836c57da2bd108c491f3ba96786f6aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#a836c57da2bd108c491f3ba96786f6aa4">More...</a><br /></td></tr>
<tr class="separator:a836c57da2bd108c491f3ba96786f6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa3f330b2354859d8a9e6df794a1e7a1a">any_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#aa3f330b2354859d8a9e6df794a1e7a1a">More...</a><br /></td></tr>
<tr class="separator:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">all_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#aaf7abb6066c8adfe6959691c3a3ea4e2">More...</a><br /></td></tr>
<tr class="separator:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4066165c960917a330beeed75a0f96e7"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a4066165c960917a330beeed75a0f96e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4066165c960917a330beeed75a0f96e7">all_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a4066165c960917a330beeed75a0f96e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#a4066165c960917a330beeed75a0f96e7">More...</a><br /></td></tr>
<tr class="separator:a4066165c960917a330beeed75a0f96e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">none_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#a2a3ff8b7f73d480ac0827f9a41a3c92a">More...</a><br /></td></tr>
<tr class="separator:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa05e58774ee8e9e05cd3e6ed2a2fa372">none_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#aa05e58774ee8e9e05cd3e6ed2a2fa372">More...</a><br /></td></tr>
<tr class="separator:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa528865cc4a45d4eb276329554f16b4b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:aa528865cc4a45d4eb276329554f16b4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">count</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:aa528865cc4a45d4eb276329554f16b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#aa528865cc4a45d4eb276329554f16b4b">More...</a><br /></td></tr>
<tr class="separator:aa528865cc4a45d4eb276329554f16b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8400202fc4005dbade0f479dd556ec3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae8400202fc4005dbade0f479dd556ec3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ae8400202fc4005dbade0f479dd556ec3">count</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:ae8400202fc4005dbade0f479dd556ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#ae8400202fc4005dbade0f479dd556ec3">More...</a><br /></td></tr>
<tr class="separator:ae8400202fc4005dbade0f479dd556ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a379c05d482a52137f5647783fe27"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a8e6a379c05d482a52137f5647783fe27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">count_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a8e6a379c05d482a52137f5647783fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#a8e6a379c05d482a52137f5647783fe27">More...</a><br /></td></tr>
<tr class="separator:a8e6a379c05d482a52137f5647783fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e22b56a1f28a353659fed572f33f5a9"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a9e22b56a1f28a353659fed572f33f5a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a9e22b56a1f28a353659fed572f33f5a9">count_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a9e22b56a1f28a353659fed572f33f5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#a9e22b56a1f28a353659fed572f33f5a9">More...</a><br /></td></tr>
<tr class="separator:a9e22b56a1f28a353659fed572f33f5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd971bc9f9c098df8422e221adfb199f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:afd971bc9f9c098df8422e221adfb199f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#afd971bc9f9c098df8422e221adfb199f">for_each</a> (R &amp;&amp;range, F &amp;&amp;func)</td></tr>
<tr class="memdesc:afd971bc9f9c098df8422e221adfb199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#afd971bc9f9c098df8422e221adfb199f">More...</a><br /></td></tr>
<tr class="separator:afd971bc9f9c098df8422e221adfb199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a76e2ce1a497aa3726cc9d99fb320ac67">for_each</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#a76e2ce1a497aa3726cc9d99fb320ac67">More...</a><br /></td></tr>
<tr class="separator:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R &gt; </td></tr>
<tr class="memitem:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a11fcae12055a2bcf5ac7c41e25e74a32">to_container</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#a11fcae12055a2bcf5ac7c41e25e74a32">More...</a><br /></td></tr>
<tr class="separator:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac33763a1f49060e179c2c2053ec07a2"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aac33763a1f49060e179c2c2053ec07a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aac33763a1f49060e179c2c2053ec07a2">to_container</a> ()</td></tr>
<tr class="memdesc:aac33763a1f49060e179c2c2053ec07a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#aac33763a1f49060e179c2c2053ec07a2">More...</a><br /></td></tr>
<tr class="separator:aac33763a1f49060e179c2c2053ec07a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a5ce2d92c6f0b3dd5eb6d70600e949a97">mismatch</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first position where two ranges differ.  <a href="#a5ce2d92c6f0b3dd5eb6d70600e949a97">More...</a><br /></td></tr>
<tr class="separator:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7d4f08068e85923f475a069c3daeb7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a7c7d4f08068e85923f475a069c3daeb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">find</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a7c7d4f08068e85923f475a069c3daeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a7c7d4f08068e85923f475a069c3daeb7">More...</a><br /></td></tr>
<tr class="separator:a7c7d4f08068e85923f475a069c3daeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f60e134164914703fdd0508f83ee11"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a37f60e134164914703fdd0508f83ee11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a37f60e134164914703fdd0508f83ee11">find</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a37f60e134164914703fdd0508f83ee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a37f60e134164914703fdd0508f83ee11">More...</a><br /></td></tr>
<tr class="separator:a37f60e134164914703fdd0508f83ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd71a185a2510e691dcd715a31edf53"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:acbd71a185a2510e691dcd715a31edf53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">find_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:acbd71a185a2510e691dcd715a31edf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#acbd71a185a2510e691dcd715a31edf53">More...</a><br /></td></tr>
<tr class="separator:acbd71a185a2510e691dcd715a31edf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04200b08ecdef8daf99f04c58f29e459"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a04200b08ecdef8daf99f04c58f29e459"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a04200b08ecdef8daf99f04c58f29e459">find_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a04200b08ecdef8daf99f04c58f29e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#a04200b08ecdef8daf99f04c58f29e459">More...</a><br /></td></tr>
<tr class="separator:a04200b08ecdef8daf99f04c58f29e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af758ef3c67d20ba6260319cb0e0171c5"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:af758ef3c67d20ba6260319cb0e0171c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">find_if_not</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:af758ef3c67d20ba6260319cb0e0171c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#af758ef3c67d20ba6260319cb0e0171c5">More...</a><br /></td></tr>
<tr class="separator:af758ef3c67d20ba6260319cb0e0171c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a406c37a2cf758e7329bfd696a6bf8f89">find_if_not</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a406c37a2cf758e7329bfd696a6bf8f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#a406c37a2cf758e7329bfd696a6bf8f89">More...</a><br /></td></tr>
<tr class="separator:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0f36ff683cedc9090956ea389b3312"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a1d0f36ff683cedc9090956ea389b3312"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">copy</a> (R1 &amp;&amp;in, R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:a1d0f36ff683cedc9090956ea389b3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in range into an other.  <a href="#a1d0f36ff683cedc9090956ea389b3312">More...</a><br /></td></tr>
<tr class="separator:a1d0f36ff683cedc9090956ea389b3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3873d79b7f878223f24062ba562eba9"><td class="memTemplParams" colspan="2">template&lt;typename R2 &gt; </td></tr>
<tr class="memitem:ab3873d79b7f878223f24062ba562eba9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ab3873d79b7f878223f24062ba562eba9">copy</a> (R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:ab3873d79b7f878223f24062ba562eba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in range into an other.  <a href="#ab3873d79b7f878223f24062ba562eba9">More...</a><br /></td></tr>
<tr class="separator:ab3873d79b7f878223f24062ba562eba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6edf0b665289e26018fa3457e25cd6c"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename V &gt; </td></tr>
<tr class="memitem:ad6edf0b665289e26018fa3457e25cd6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ad6edf0b665289e26018fa3457e25cd6c">fill</a> (R1 &amp;&amp;in, V &amp;&amp;value)</td></tr>
<tr class="memdesc:ad6edf0b665289e26018fa3457e25cd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range [first, last)  <a href="#ad6edf0b665289e26018fa3457e25cd6c">More...</a><br /></td></tr>
<tr class="separator:ad6edf0b665289e26018fa3457e25cd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc470cd5701a27ad3388c1b1d07d705"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a4dc470cd5701a27ad3388c1b1d07d705"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4dc470cd5701a27ad3388c1b1d07d705">fill</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a4dc470cd5701a27ad3388c1b1d07d705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the given value to the elements in the range [first, last)  <a href="#a4dc470cd5701a27ad3388c1b1d07d705">More...</a><br /></td></tr>
<tr class="separator:a4dc470cd5701a27ad3388c1b1d07d705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2734b7f57efb773c6df8ac55b9d040cd"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a2734b7f57efb773c6df8ac55b9d040cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a2734b7f57efb773c6df8ac55b9d040cd">back_insert</a> (R1 &amp;&amp;in, R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:a2734b7f57efb773c6df8ac55b9d040cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>in</em> in back of <em>front</em>  <a href="#a2734b7f57efb773c6df8ac55b9d040cd">More...</a><br /></td></tr>
<tr class="separator:a2734b7f57efb773c6df8ac55b9d040cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3ab6d88fc54b3638ef699d465e86b4"><td class="memTemplParams" colspan="2">template&lt;typename R2 &gt; </td></tr>
<tr class="memitem:a1c3ab6d88fc54b3638ef699d465e86b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a1c3ab6d88fc54b3638ef699d465e86b4">back_insert</a> (R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:a1c3ab6d88fc54b3638ef699d465e86b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>in</em> in back of <em>front</em>  <a href="#a1c3ab6d88fc54b3638ef699d465e86b4">More...</a><br /></td></tr>
<tr class="separator:a1c3ab6d88fc54b3638ef699d465e86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550a133fe8c6de600a83959c82a0c592"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 , typename P &gt; </td></tr>
<tr class="memitem:a550a133fe8c6de600a83959c82a0c592"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a550a133fe8c6de600a83959c82a0c592">copy_if</a> (R1 &amp;&amp;in, R2 &amp;&amp;out, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a550a133fe8c6de600a83959c82a0c592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements for which the predicate pred returns true.  <a href="#a550a133fe8c6de600a83959c82a0c592">More...</a><br /></td></tr>
<tr class="separator:a550a133fe8c6de600a83959c82a0c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f17e9431b258cc701fa59672a65d7db"><td class="memTemplParams" colspan="2">template&lt;typename R2 , typename P &gt; </td></tr>
<tr class="memitem:a1f17e9431b258cc701fa59672a65d7db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a1f17e9431b258cc701fa59672a65d7db">copy_if</a> (R2 &amp;&amp;out, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a1f17e9431b258cc701fa59672a65d7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements for which the predicate pred returns true.  <a href="#a1f17e9431b258cc701fa59672a65d7db">More...</a><br /></td></tr>
<tr class="separator:a1f17e9431b258cc701fa59672a65d7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85af749badb4261aa3c97a1d98134493"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a85af749badb4261aa3c97a1d98134493"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">size</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a85af749badb4261aa3c97a1d98134493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#a85af749badb4261aa3c97a1d98134493">More...</a><br /></td></tr>
<tr class="separator:a85af749badb4261aa3c97a1d98134493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaee48fa7a804b4fd19c6a78bdd8d4c85">size</a> ()</td></tr>
<tr class="memdesc:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#aaee48fa7a804b4fd19c6a78bdd8d4c85">More...</a><br /></td></tr>
<tr class="separator:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">equal</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:abf321dffb33d6a2d752aa091fdba7bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two sets of elements are the same.  <a href="#abf321dffb33d6a2d752aa091fdba7bbf">More...</a><br /></td></tr>
<tr class="separator:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3434aacc26937d3ff50b5db4286feda6"><td class="memTemplParams" colspan="2">template&lt;typename R1 &gt; </td></tr>
<tr class="memitem:a3434aacc26937d3ff50b5db4286feda6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a3434aacc26937d3ff50b5db4286feda6">equal</a> (R1 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a3434aacc26937d3ff50b5db4286feda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two sets of elements are the same.  <a href="#a3434aacc26937d3ff50b5db4286feda6">More...</a><br /></td></tr>
<tr class="separator:a3434aacc26937d3ff50b5db4286feda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7b590b1bd8a44b5b2d6f4e35f1837c"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a3f7b590b1bd8a44b5b2d6f4e35f1837c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a3f7b590b1bd8a44b5b2d6f4e35f1837c">stream_inserter</a> (S &amp;&amp;stream)</td></tr>
<tr class="memdesc:a3f7b590b1bd8a44b5b2d6f4e35f1837c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range which output to a stream.  <a href="#a3f7b590b1bd8a44b5b2d6f4e35f1837c">More...</a><br /></td></tr>
<tr class="separator:a3f7b590b1bd8a44b5b2d6f4e35f1837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba9495316f20f6caee735c15feb349c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:afba9495316f20f6caee735c15feb349c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#afba9495316f20f6caee735c15feb349c">remove_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:afba9495316f20f6caee735c15feb349c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep at the begining of the range only elements for which pred(elt) is false<br />
.  <a href="#afba9495316f20f6caee735c15feb349c">More...</a><br /></td></tr>
<tr class="separator:afba9495316f20f6caee735c15feb349c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598cf91c554f6d6938c320578e6bb02"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:af598cf91c554f6d6938c320578e6bb02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#af598cf91c554f6d6938c320578e6bb02">remove_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:af598cf91c554f6d6938c320578e6bb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep at the begining of the range only elements for which pred(elt) is false<br />
.  <a href="#af598cf91c554f6d6938c320578e6bb02">More...</a><br /></td></tr>
<tr class="separator:af598cf91c554f6d6938c320578e6bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ae3ed90fe486c2dd3a90fee811bcd7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a97ae3ed90fe486c2dd3a90fee811bcd7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a97ae3ed90fe486c2dd3a90fee811bcd7">partition</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a97ae3ed90fe486c2dd3a90fee811bcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the <b>range</b> in such a way that all elements for which the predicate <b>pred</b> returns <code>true</code> precede the elements for which predicate <b>pred</b> returns <code>false</code>.  <a href="#a97ae3ed90fe486c2dd3a90fee811bcd7">More...</a><br /></td></tr>
<tr class="separator:a97ae3ed90fe486c2dd3a90fee811bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeced5adb7a17c0c8f34b64559ddc60c"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:afeced5adb7a17c0c8f34b64559ddc60c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#afeced5adb7a17c0c8f34b64559ddc60c">partition</a> (P &amp;&amp;pred)</td></tr>
<tr class="separator:afeced5adb7a17c0c8f34b64559ddc60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184b21a98515705f9b4845875fb689b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:ac184b21a98515705f9b4845875fb689b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ac184b21a98515705f9b4845875fb689b">stable_partition</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:ac184b21a98515705f9b4845875fb689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the <b>range</b> in such a way that all elements for which the predicate <b>pred</b> returns <code>true</code> precede the elements for which predicate <b>pred</b> returns false.  <a href="#ac184b21a98515705f9b4845875fb689b">More...</a><br /></td></tr>
<tr class="separator:ac184b21a98515705f9b4845875fb689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c8e542493089f60675db2d0018329"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:ae51c8e542493089f60675db2d0018329"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ae51c8e542493089f60675db2d0018329">stable_partition</a> (P &amp;&amp;pred)</td></tr>
<tr class="separator:ae51c8e542493089f60675db2d0018329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b055c0e04f784b9abc89a27ef4534dd"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R &gt; </td></tr>
<tr class="memitem:a3b055c0e04f784b9abc89a27ef4534dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a3b055c0e04f784b9abc89a27ef4534dd">erase</a> (C &amp;&amp;container, R &amp;&amp;subrange)</td></tr>
<tr class="memdesc:a3b055c0e04f784b9abc89a27ef4534dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sub-range of a given container.  <a href="#a3b055c0e04f784b9abc89a27ef4534dd">More...</a><br /></td></tr>
<tr class="separator:a3b055c0e04f784b9abc89a27ef4534dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ea7a94642c23e9f3db6f6b890f2987"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a80ea7a94642c23e9f3db6f6b890f2987"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a80ea7a94642c23e9f3db6f6b890f2987">erase</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a80ea7a94642c23e9f3db6f6b890f2987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a sub-range of a given container.  <a href="#a80ea7a94642c23e9f3db6f6b890f2987">More...</a><br /></td></tr>
<tr class="separator:a80ea7a94642c23e9f3db6f6b890f2987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc4f7618438272f7ec9f3c819d5990"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P  = is_lesser, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a02bc4f7618438272f7ec9f3c819d5990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a02bc4f7618438272f7ec9f3c819d5990">sort</a> (R &amp;range, P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:a02bc4f7618438272f7ec9f3c819d5990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a range in place, using the given predicate.  <a href="#a02bc4f7618438272f7ec9f3c819d5990">More...</a><br /></td></tr>
<tr class="separator:a02bc4f7618438272f7ec9f3c819d5990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a938d529ef4564281a5dca2ce49b538"><td class="memTemplParams" colspan="2">template&lt;typename P  = is_lesser, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a3a938d529ef4564281a5dca2ce49b538"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a3a938d529ef4564281a5dca2ce49b538">sort</a> (P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:a3a938d529ef4564281a5dca2ce49b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a range in place, using the given predicate.  <a href="#a3a938d529ef4564281a5dca2ce49b538">More...</a><br /></td></tr>
<tr class="separator:a3a938d529ef4564281a5dca2ce49b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215c9f80364af9121e2be42d1ebacdbf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P  = is_lesser, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a215c9f80364af9121e2be42d1ebacdbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a215c9f80364af9121e2be42d1ebacdbf">stable_sort</a> (R &amp;range, P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:a215c9f80364af9121e2be42d1ebacdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range in ascending order.  <a href="#a215c9f80364af9121e2be42d1ebacdbf">More...</a><br /></td></tr>
<tr class="separator:a215c9f80364af9121e2be42d1ebacdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45a27d7e9403b82624632e1ee3daf6f"><td class="memTemplParams" colspan="2">template&lt;typename P  = is_lesser, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aa45a27d7e9403b82624632e1ee3daf6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa45a27d7e9403b82624632e1ee3daf6f">stable_sort</a> (P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:aa45a27d7e9403b82624632e1ee3daf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in the range in ascending order.  <a href="#aa45a27d7e9403b82624632e1ee3daf6f">More...</a><br /></td></tr>
<tr class="separator:aa45a27d7e9403b82624632e1ee3daf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d00692710a6ee8e5b3110a56bbd59c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename URBG &gt; </td></tr>
<tr class="memitem:ab1d00692710a6ee8e5b3110a56bbd59c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ab1d00692710a6ee8e5b3110a56bbd59c">shuffle</a> (R &amp;range, URBG &amp;&amp;g)</td></tr>
<tr class="memdesc:ab1d00692710a6ee8e5b3110a56bbd59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the given range such that each possible permutation of those elements has equal probability of appearance.  <a href="#ab1d00692710a6ee8e5b3110a56bbd59c">More...</a><br /></td></tr>
<tr class="separator:ab1d00692710a6ee8e5b3110a56bbd59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f2ab22986c011ca40816c52638e0ad"><td class="memTemplParams" colspan="2">template&lt;typename URBG &gt; </td></tr>
<tr class="memitem:a93f2ab22986c011ca40816c52638e0ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a93f2ab22986c011ca40816c52638e0ad">shuffle</a> (URBG &amp;&amp;g)</td></tr>
<tr class="memdesc:a93f2ab22986c011ca40816c52638e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the elements in the given range such that each possible permutation of those elements has equal probability of appearance.  <a href="#a93f2ab22986c011ca40816c52638e0ad">More...</a><br /></td></tr>
<tr class="separator:a93f2ab22986c011ca40816c52638e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4f0afb068c908600b357e111148df7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P  = is_equal, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7c4f0afb068c908600b357e111148df7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7c4f0afb068c908600b357e111148df7">unique</a> (R &amp;&amp;range, P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:a7c4f0afb068c908600b357e111148df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all but first successuve values which are equals.  <a href="#a7c4f0afb068c908600b357e111148df7">More...</a><br /></td></tr>
<tr class="separator:a7c4f0afb068c908600b357e111148df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbbb6f9bd014675985d33d93221acca"><td class="memTemplParams" colspan="2">template&lt;typename P  = is_equal, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aafbbb6f9bd014675985d33d93221acca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aafbbb6f9bd014675985d33d93221acca">unique</a> (P &amp;&amp;pred={})</td></tr>
<tr class="memdesc:aafbbb6f9bd014675985d33d93221acca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all but first successuve values which are equals.  <a href="#aafbbb6f9bd014675985d33d93221acca">More...</a><br /></td></tr>
<tr class="separator:aafbbb6f9bd014675985d33d93221acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8dbcc943f7c503acea5f58f231a5af"><td class="memTemplParams" colspan="2">template&lt;typename IN1 , typename IN2 , typename OUT &gt; </td></tr>
<tr class="memitem:aca8dbcc943f7c503acea5f58f231a5af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aca8dbcc943f7c503acea5f58f231a5af">set_difference</a> (IN1 &amp;&amp;in1, IN2 &amp;&amp;in2, OUT &amp;&amp;out)</td></tr>
<tr class="memdesc:aca8dbcc943f7c503acea5f58f231a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range in1 which are not found in the sorted range in2 to the range out The resulting range is also sorted.  <a href="#aca8dbcc943f7c503acea5f58f231a5af">More...</a><br /></td></tr>
<tr class="separator:aca8dbcc943f7c503acea5f58f231a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb09a0285e2a6814b8aa99f90ba987"><td class="memTemplParams" colspan="2">template&lt;typename IN1 , typename IN2 , typename OUT &gt; </td></tr>
<tr class="memitem:a41cb09a0285e2a6814b8aa99f90ba987"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a41cb09a0285e2a6814b8aa99f90ba987">set_intersection</a> (IN1 &amp;&amp;in1, IN2 &amp;&amp;in2, OUT &amp;&amp;out)</td></tr>
<tr class="memdesc:a41cb09a0285e2a6814b8aa99f90ba987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from the sorted range in1 which are also found in the sorted range in2 to the range out The resulting range is also sorted.  <a href="#a41cb09a0285e2a6814b8aa99f90ba987">More...</a><br /></td></tr>
<tr class="separator:a41cb09a0285e2a6814b8aa99f90ba987"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5af06eebbd592c36368022990839b982"><td class="memItemLeft" align="right" valign="top">constexpr intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah.html#a5af06eebbd592c36368022990839b982">End</a> = -1</td></tr>
<tr class="memdesc:a5af06eebbd592c36368022990839b982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used with <a class="el" href="namespacerah_1_1view.html#a26e48a024bda08769061de4ad6addd9c" title="Create a view that is a sub-range of a range.">rah::view::slice</a> to point to the end.  <a href="#a5af06eebbd592c36368022990839b982">More...</a><br /></td></tr>
<tr class="separator:a5af06eebbd592c36368022990839b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a28aff4eeddcece6be65ff0b956d32d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aff4eeddcece6be65ff0b956d32d4a">&#9670;&nbsp;</a></span>range_begin_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">rah::range_begin_type_t</a> = typedef decltype(<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9657e24ae477f4482225b133fe286b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9657e24ae477f4482225b133fe286b65">&#9670;&nbsp;</a></span>range_end_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a9657e24ae477f4482225b133fe286b65">rah::range_end_type_t</a> = typedef decltype(<a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cdcceefd4c7ad3abffb96560d24517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdcceefd4c7ad3abffb96560d24517d">&#9670;&nbsp;</a></span>range_iter_categ_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a7cdcceefd4c7ad3abffb96560d24517d">rah::range_iter_categ_t</a> = typedef typename std ::iterator_traits&lt;<a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a>&lt;R&gt; &gt;::iterator_category</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6622426bea22e9509614fe4c574ebeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6622426bea22e9509614fe4c574ebeca">&#9670;&nbsp;</a></span>range_ref_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">rah::range_ref_type_t</a> = typedef decltype(*<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c0c45ea6e732dc2668edfd0e4f8fccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0c45ea6e732dc2668edfd0e4f8fccf">&#9670;&nbsp;</a></span>range_value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a0c0c45ea6e732dc2668edfd0e4f8fccf">rah::range_value_type_t</a> = typedef std ::remove_reference_t&lt;<a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf7abb6066c8adfe6959691c3a3ea4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7abb6066c8adfe6959691c3a3ea4e2">&#9670;&nbsp;</a></span>all_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::all_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">rah::all_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 4, 4 },</div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="a4066165c960917a330beeed75a0f96e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4066165c960917a330beeed75a0f96e7">&#9670;&nbsp;</a></span>all_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::all_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 3, 4 }</div><div class="line">    | <a class="code" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">rah::all_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">        ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a836c57da2bd108c491f3ba96786f6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836c57da2bd108c491f3ba96786f6aa4">&#9670;&nbsp;</a></span>any_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::any_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">rah::any_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 3, 0, 1, 3, 4, 6 },</div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="aa3f330b2354859d8a9e6df794a1e7a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f330b2354859d8a9e6df794a1e7a1a">&#9670;&nbsp;</a></span>any_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::any_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((</div><div class="line">        std::initializer_list&lt;int&gt;{0, 1, 2, 3, 4, 6}</div><div class="line">    | <a class="code" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">rah::any_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">        ));</div></div><!-- fragment -->
</div>
</div>
<a id="a2734b7f57efb773c6df8ac55b9d040cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2734b7f57efb773c6df8ac55b9d040cd">&#9670;&nbsp;</a></span>back_insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::back_insert </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert <em>in</em> in back of <em>front</em> </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 10 };</div><div class="line">        <a class="code" href="namespacerah.html#a2734b7f57efb773c6df8ac55b9d040cd">rah::back_insert</a>(in, out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 10, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a1c3ab6d88fc54b3638ef699d465e86b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3ab6d88fc54b3638ef699d465e86b4">&#9670;&nbsp;</a></span>back_insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::back_insert </td>
          <td>(</td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert <em>in</em> in back of <em>front</em> </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 10 };</div><div class="line">        in | <a class="code" href="namespacerah.html#a2734b7f57efb773c6df8ac55b9d040cd">rah::back_insert</a>(out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 10, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a0698f952bc3c4f1961929bbddb5812fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0698f952bc3c4f1961929bbddb5812fe">&#9670;&nbsp;</a></span>back_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::back_inserter </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a range which insert into the back of the a container. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out;</div><div class="line">        <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(in, <a class="code" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">rah::back_inserter</a>(out));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a2c4a19e57cc4e0753e93830f247def6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4a19e57cc4e0753e93830f247def6d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the begin iterator of the range. </p>

</div>
</div>
<a id="a14e69321e6772651b349cb31467ea3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e69321e6772651b349cb31467ea3a2">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the begin iterator of the range. </p>

</div>
</div>
<a id="a5eef379d9f3039fd12f43d5220434976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eef379d9f3039fd12f43d5220434976">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::binary_search </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an element equivalent to value appears within the range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 2, 3, 4 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(not <a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(vecIn1, 0));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(vecIn1, 1));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(vecIn1, 2));</div></div><!-- fragment -->
</div>
</div>
<a id="a8ac532c28d2c52c80adf91a7b8829bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac532c28d2c52c80adf91a7b8829bd6">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::binary_search </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an element equivalent to value appears within the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 2, 3, 4 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(not (vecIn1 | <a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(0)));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(vecIn1 | <a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(1));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(vecIn1 | <a class="code" href="namespacerah.html#a5eef379d9f3039fd12f43d5220434976">rah::binary_search</a>(2));</div></div><!-- fragment -->
</div>
</div>
<a id="a1d0f36ff683cedc9090956ea389b3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0f36ff683cedc9090956ea389b3312">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in range into an other. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        <span class="comment">// std::vector&lt;int&gt; out{ 0, 0 }; // Trigger an assert</span></div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(<a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(in, out), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 4, 5 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ab3873d79b7f878223f24062ba562eba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3873d79b7f878223f24062ba562eba9">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy </td>
          <td>(</td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in range into an other. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> iter = in | <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;{ 4, 5 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a550a133fe8c6de600a83959c82a0c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550a133fe8c6de600a83959c82a0c592">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy_if </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements for which the predicate pred returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 5, 6 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(<a class="code" href="namespacerah.html#a550a133fe8c6de600a83959c82a0c592">rah::copy_if</a>(in, out, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i % 2 == 0; }), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 5, 6 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 2, 4, 5, 6 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a1f17e9431b258cc701fa59672a65d7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f17e9431b258cc701fa59672a65d7db">&#9670;&nbsp;</a></span>copy_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R2 , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy_if </td>
          <td>(</td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements for which the predicate pred returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 5, 6 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(in | <a class="code" href="namespacerah.html#a550a133fe8c6de600a83959c82a0c592">rah::copy_if</a>(out, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i % 2 == 0; }), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 5, 6 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 2, 4, 5, 6 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aa528865cc4a45d4eb276329554f16b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa528865cc4a45d4eb276329554f16b4b">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">rah::count</a>(std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 }, 3) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="ae8400202fc4005dbade0f479dd556ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8400202fc4005dbade0f479dd556ec3">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">rah::count</a>(4)) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a8e6a379c05d482a52137f5647783fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a379c05d482a52137f5647783fe27">&#9670;&nbsp;</a></span>count_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">rah::count_if</a>(std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 }, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; }) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a9e22b56a1f28a353659fed572f33f5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e22b56a1f28a353659fed572f33f5a9">&#9670;&nbsp;</a></span>count_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">rah::count_if</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="a51feb1497566c28de396f50735fd259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51feb1497566c28de396f50735fd259b">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::empty </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the range if empty. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(not (<a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>(std::vector&lt;int&gt;{ 1, 2, 3 })));</div><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>(std::vector&lt;int&gt;()));</div></div><!-- fragment -->
</div>
</div>
<a id="a6ceb90c934b1c4927ab4e08b985ef6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb90c934b1c4927ab4e08b985ef6c5">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rah::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the range if empty. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(not (std::vector&lt;int&gt;{ 1, 2, 3 } | <a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>()));</div><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(std::vector&lt;int&gt;() | <a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>());</div></div><!-- fragment -->
</div>
</div>
<a id="aaddd1442cd76b96876e692cdefe7261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddd1442cd76b96876e692cdefe7261d">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "past the" end iterator of the range. </p>

</div>
</div>
<a id="a6b31fe80bf81abf3149df010cb265e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31fe80bf81abf3149df010cb265e20">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "past the" end iterator of the range. </p>

</div>
</div>
<a id="abf321dffb33d6a2d752aa091fdba7bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf321dffb33d6a2d752aa091fdba7bbf">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two sets of elements are the same. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in3{ 11, 12, 13 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in1, in2));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in1, in3) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a3434aacc26937d3ff50b5db4286feda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3434aacc26937d3ff50b5db4286feda6">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two sets of elements are the same. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in3{ 11, 12, 13 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in1 | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in2));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(not (in1 | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in3)));</div></div><!-- fragment -->
</div>
</div>
<a id="a095c61033422b8ebe6dc2cc214867aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095c61033422b8ebe6dc2cc214867aca">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal_range </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 2, 3, 4 };</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(vecIn1, 0))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ }));</div><div class="line">        }</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(vecIn1, 1))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 1 }));</div><div class="line">        }</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(vecIn1, 2))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 2, 2 }));</div><div class="line">        }</div></div><!-- fragment -->
</div>
</div>
<a id="afa191bbe5b7dbb9b2e7a21a87dbb9a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa191bbe5b7dbb9b2e7a21a87dbb9a8a">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal_range </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a range containing all elements equivalent to value in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 2, 3, 4 };</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : vecIn1 | <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(0))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ }));</div><div class="line">        }</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : vecIn1 | <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(1))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 1 }));</div><div class="line">        }</div><div class="line">        {</div><div class="line">            std::vector&lt;int&gt; out;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : vecIn1 | <a class="code" href="namespacerah.html#a095c61033422b8ebe6dc2cc214867aca">rah::equal_range</a>(2))</div><div class="line">                out.push_back(i);</div><div class="line">            <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 2, 2 }));</div><div class="line">        }</div></div><!-- fragment -->
</div>
</div>
<a id="a3b055c0e04f784b9abc89a27ef4534dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b055c0e04f784b9abc89a27ef4534dd">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::erase </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>subrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a sub-range of a given container. </p>
<dl class="section return"><dt>Returns</dt><dd>A view on the resulting container</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <a class="code" href="namespacerah.html#a3b055c0e04f784b9abc89a27ef4534dd">rah::erase</a>(in, <a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(in), <a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(in) + 3));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a80ea7a94642c23e9f3db6f6b890f2987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ea7a94642c23e9f3db6f6b890f2987">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::erase </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a sub-range of a given container. </p>
<dl class="section return"><dt>Returns</dt><dd>A view on the resulting container </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        in | <a class="code" href="namespacerah.html#a3b055c0e04f784b9abc89a27ef4534dd">rah::erase</a>(<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(in), <a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(in) + 3));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a11785bbdf970efa1bc57fc14993b77bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11785bbdf970efa1bc57fc14993b77bf">&#9670;&nbsp;</a></span>fake()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; rah::fake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in decltype to get an instance of a type. </p>

</div>
</div>
<a id="ad6edf0b665289e26018fa3457e25cd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6edf0b665289e26018fa3457e25cd6c">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::fill </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range [first, last) </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        <span class="comment">// std::vector&lt;int&gt; out{ 0, 0 }; // Trigger an assert</span></div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(<a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(in, out), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 4, 5 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a4dc470cd5701a27ad3388c1b1d07d705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc470cd5701a27ad3388c1b1d07d705">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::fill </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the given value to the elements in the range [first, last) </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> iter = in | <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(out)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;{ 4, 5 })));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7c7d4f08068e85923f475a069c3daeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7d4f08068e85923f475a069c3daeb7">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = <a class="code" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">rah::find</a>(in, 3);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            (<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a37f60e134164914703fdd0508f83ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f60e134164914703fdd0508f83ee11">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = in | <a class="code" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">rah::find</a>(3);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            (<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="acbd71a185a2510e691dcd715a31edf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd71a185a2510e691dcd715a31edf53">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = <a class="code" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">rah::find_if</a>(in, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            (<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">            );</div></div><!-- fragment -->
</div>
</div>
<a id="a04200b08ecdef8daf99f04c58f29e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04200b08ecdef8daf99f04c58f29e459">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = in | <a class="code" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">rah::find_if</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            (<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">            );</div></div><!-- fragment -->
</div>
</div>
<a id="af758ef3c67d20ba6260319cb0e0171c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af758ef3c67d20ba6260319cb0e0171c5">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if_not </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = <a class="code" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">rah::find_if_not</a>(in, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 }))));</div></div><!-- fragment -->
</div>
</div>
<a id="a406c37a2cf758e7329bfd696a6bf8f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406c37a2cf758e7329bfd696a6bf8f89">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if_not </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4 };</div><div class="line">        <span class="keyword">auto</span> iter = in | <a class="code" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">rah::find_if_not</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((<a class="code" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">rah::make_iterator_range</a>(iter, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in)) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 }))));</div></div><!-- fragment -->
</div>
</div>
<a id="afd971bc9f9c098df8422e221adfb199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd971bc9f9c098df8422e221adfb199f">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::for_each </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        <a class="code" href="namespacerah.html#afd971bc9f9c098df8422e221adfb199f">rah::for_each</a>(testFE, [](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        <a class="code" href="test_8cpp.html#a6dfa1ab8c6c66d07f06143ad32241d72">EQUAL_RANGE</a>(testFE, std::initializer_list&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a76e2ce1a497aa3726cc9d99fb320ac67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2ce1a497aa3726cc9d99fb320ac67">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        testFE | <a class="code" href="namespacerah.html#afd971bc9f9c098df8422e221adfb199f">rah::for_each</a>([](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        <a class="code" href="test_8cpp.html#a6dfa1ab8c6c66d07f06143ad32241d72">EQUAL_RANGE</a>(testFE, std::initializer_list&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a4e145bfeb8a932058e20fc4cb4e7c206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e145bfeb8a932058e20fc4cb4e7c206">&#9670;&nbsp;</a></span>make_iterator_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rah::make_iterator_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structrah_1_1iterator__range.html">rah::iterator_range</a> with two given iterators. </p>

</div>
</div>
<a id="a274b78c4c0af5dd58ce280f02223fb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b78c4c0af5dd58ce280f02223fb55">&#9670;&nbsp;</a></span>make_pipeable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rah::make_pipeable </td>
          <td>(</td>
          <td class="paramtype">MakeRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>make_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to create a "pipeable" function (UFCS style in c++) </p>
<h1><a class="anchor" id="create_pipeable"></a>
How to create :</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="test_8cpp.html#ae66a06c931008db2ce8bd097114223e2">test_count</a>(<span class="keywordtype">int</span> i)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacerah.html#a274b78c4c0af5dd58ce280f02223fb55">rah::make_pipeable</a>([=](<span class="keyword">auto</span>&amp;&amp; range) { <span class="keywordflow">return</span> <a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">std::count</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(range), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(range), i); });</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="use_pipeable"></a>
How to use :</h1>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec{ 0, 1, 2, 2, 3 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((vec | <a class="code" href="test_8cpp.html#ae66a06c931008db2ce8bd097114223e2">test_count</a>(2)) == 2);</div></div><!-- fragment -->
</div>
</div>
<a id="a5ce2d92c6f0b3dd5eb6d70600e949a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce2d92c6f0b3dd5eb6d70600e949a97">&#9670;&nbsp;</a></span>mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::mismatch </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first position where two ranges differ. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1 = { 1, 2, 3, 4 };</div><div class="line">        std::vector&lt;int&gt; in2 = { 1, 2, 42, 42 };</div><div class="line">        <span class="keyword">auto</span> r1_r2 = <a class="code" href="namespacerah.html#a5ce2d92c6f0b3dd5eb6d70600e949a97">rah::mismatch</a>(in1, in2);</div><div class="line">        std::vector&lt;int&gt; out1;</div><div class="line">        std::vector&lt;int&gt; out2;</div><div class="line">        <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">std::copy</a>(std::get&lt;0&gt;(r1_r2), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in1), <a class="code" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">std::back_inserter</a>(out1));</div><div class="line">        <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">std::copy</a>(std::get&lt;1&gt;(r1_r2), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in2), <a class="code" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">std::back_inserter</a>(out2));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out1 == std::vector&lt;int&gt;({ 3, 4 }));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out2 == std::vector&lt;int&gt;({ 42, 42 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a2a3ff8b7f73d480ac0827f9a41a3c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ff8b7f73d480ac0827f9a41a3c92a">&#9670;&nbsp;</a></span>none_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::none_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((<a class="code" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">rah::none_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10},</div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">        ));</div></div><!-- fragment -->
</div>
</div>
<a id="aa05e58774ee8e9e05cd3e6ed2a2fa372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05e58774ee8e9e05cd3e6ed2a2fa372">&#9670;&nbsp;</a></span>none_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::none_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10, 11}</div><div class="line">    | <a class="code" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">rah::none_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">        ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="ab1ae71c44092414b8a22379bc0d3cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ae71c44092414b8a22379bc0d3cd34">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::operator| </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrah_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;&#160;</td>
          <td class="paramname"><em>adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(adapter.func( std ::forward&lt;R&gt;(range)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97ae3ed90fe486c2dd3a90fee811bcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ae3ed90fe486c2dd3a90fee811bcd7">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::partition </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the <b>range</b> in such a way that all elements for which the predicate <b>pred</b> returns <code>true</code> precede the elements for which predicate <b>pred</b> returns <code>false</code>. </p>
<p>Relative order of the elements is not preserved. </p><dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the second group.</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> boundary = <a class="code" href="namespacerah.html#a97ae3ed90fe486c2dd3a90fee811bcd7">rah::partition</a>(in, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a &gt;= 4; });</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(in.begin(), boundary);</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(boundary, in.end());</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="afeced5adb7a17c0c8f34b64559ddc60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeced5adb7a17c0c8f34b64559ddc60c">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::partition </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerah.html#a97ae3ed90fe486c2dd3a90fee811bcd7" title="Reorders the elements in the range in such a way that all elements for which the predicate pred retur...">rah::partition(R&amp;&amp;, P&amp;&amp;)</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> boundary = in | <a class="code" href="namespacerah.html#a97ae3ed90fe486c2dd3a90fee811bcd7">rah::partition</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a &gt;= 4; });</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(in.begin(), boundary);</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(boundary, in.end());</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a407b50a4f029e3f2a3cd0ba9142aea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407b50a4f029e3f2a3cd0ba9142aea84">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::reduce </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">rah::reduce</a>(vecIn1, 0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; }) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="a6a6b7b7e3b78bb4bd16372fbb688c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6b7b7e3b78bb4bd16372fbb688c152">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::reduce </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((vecIn1 | <a class="code" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">rah::reduce</a>(0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; })) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="afba9495316f20f6caee735c15feb349c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba9495316f20f6caee735c15feb349c">&#9670;&nbsp;</a></span>remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::remove_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep at the begining of the range only elements for which pred(elt) is false<br />
. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the (end) part of the range to erase.</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> range_to_erase_begin = <a class="code" href="namespacerah.html#afba9495316f20f6caee735c15feb349c">rah::remove_if</a>(in, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a &lt; 4; });</div><div class="line">        in.erase(range_to_erase_begin, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(in.begin(), in.end());</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({4, 5}));</div></div><!-- fragment -->
</div>
</div>
<a id="af598cf91c554f6d6938c320578e6bb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af598cf91c554f6d6938c320578e6bb02">&#9670;&nbsp;</a></span>remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::remove_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep at the begining of the range only elements for which pred(elt) is false<br />
. </p>
<dl class="section return"><dt>Returns</dt><dd>The (end) part of the range to erase. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> range_to_erase_begin = in | <a class="code" href="namespacerah.html#afba9495316f20f6caee735c15feb349c">rah::remove_if</a>([](<span class="keywordtype">int</span> a) {<span class="keywordflow">return</span> a &lt; 4; });</div><div class="line">        in.erase(range_to_erase_begin, <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="namespacerah_1_1view.html#a343ff36ca2b6470f2a55a89dfb4e3dc9">std::sort</a>(in.begin(), in.end());</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aca8dbcc943f7c503acea5f58f231a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8dbcc943f7c503acea5f58f231a5af">&#9670;&nbsp;</a></span>set_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN1 , typename IN2 , typename OUT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::set_difference </td>
          <td>(</td>
          <td class="paramtype">IN1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range in1 which are not found in the sorted range in2 to the range out The resulting range is also sorted. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1,    3, 4 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3    };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespacerah.html#aca8dbcc943f7c503acea5f58f231a5af">rah::set_difference</a>(in1, in2, out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({4, 0, 0, 0}));</div></div><!-- fragment -->
</div>
</div>
<a id="a41cb09a0285e2a6814b8aa99f90ba987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cb09a0285e2a6814b8aa99f90ba987">&#9670;&nbsp;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IN1 , typename IN2 , typename OUT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::set_intersection </td>
          <td>(</td>
          <td class="paramtype">IN1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the elements from the sorted range in1 which are also found in the sorted range in2 to the range out The resulting range is also sorted. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1,    3, 4 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3    };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespacerah.html#a41cb09a0285e2a6814b8aa99f90ba987">rah::set_intersection</a>(in1, in2, out);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == std::vector&lt;int&gt;({ 1, 3, 0, 0 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ab1d00692710a6ee8e5b3110a56bbd59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d00692710a6ee8e5b3110a56bbd59c">&#9670;&nbsp;</a></span>shuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename URBG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::shuffle </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the given range such that each possible permutation of those elements has equal probability of appearance. </p>
<div class="fragment"><div class="line">        std::random_device rd;</div><div class="line">        std::mt19937 g(rd());</div><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5, 6 };</div><div class="line">        <a class="code" href="namespacerah.html#ab1d00692710a6ee8e5b3110a56bbd59c">rah::shuffle</a>(in, g);</div></div><!-- fragment -->
</div>
</div>
<a id="a93f2ab22986c011ca40816c52638e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f2ab22986c011ca40816c52638e0ad">&#9670;&nbsp;</a></span>shuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename URBG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::shuffle </td>
          <td>(</td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the given range such that each possible permutation of those elements has equal probability of appearance. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::random_device rd;</div><div class="line">        std::mt19937 g(rd());</div><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5, 6 };</div><div class="line">        in | <a class="code" href="namespacerah.html#ab1d00692710a6ee8e5b3110a56bbd59c">rah::shuffle</a>(g);</div></div><!-- fragment -->
</div>
</div>
<a id="a85af749badb4261aa3c97a1d98134493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85af749badb4261aa3c97a1d98134493">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::size </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(<a class="code" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">rah::size</a>(vec3) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="aaee48fa7a804b4fd19c6a78bdd8d4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee48fa7a804b4fd19c6a78bdd8d4c85">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rah::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>((vec3 | <a class="code" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">rah::size</a>()) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a02bc4f7618438272f7ec9f3c819d5990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bc4f7618438272f7ec9f3c819d5990">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P  = is_lesser, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::sort </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a range in place, using the given predicate. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 5, 3, 4 };</div><div class="line">        <a class="code" href="namespacerah.html#a02bc4f7618438272f7ec9f3c819d5990">rah::sort</a>(in);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 1, 2, 3, 4, 5 }));</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 5, 3, 4 };</div><div class="line">        <a class="code" href="namespacerah.html#a02bc4f7618438272f7ec9f3c819d5990">rah::sort</a>(in, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a &lt; b; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a3a938d529ef4564281a5dca2ce49b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a938d529ef4564281a5dca2ce49b538">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P  = is_lesser, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::sort </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a range in place, using the given predicate. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 5, 3, 4 };</div><div class="line">        in | <a class="code" href="namespacerah.html#a02bc4f7618438272f7ec9f3c819d5990">rah::sort</a>();</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 1, 2, 3, 4, 5 }));</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 5, 3, 4 };</div><div class="line">        in | <a class="code" href="namespacerah.html#a02bc4f7618438272f7ec9f3c819d5990">rah::sort</a>([](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a &lt; b; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ac184b21a98515705f9b4845875fb689b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac184b21a98515705f9b4845875fb689b">&#9670;&nbsp;</a></span>stable_partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::stable_partition </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorders the elements in the <b>range</b> in such a way that all elements for which the predicate <b>pred</b> returns <code>true</code> precede the elements for which predicate <b>pred</b> returns false. </p>
<p>Relative order of the elements is preserved. </p><dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the second group.</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> boundary = <a class="code" href="namespacerah.html#ac184b21a98515705f9b4845875fb689b">rah::stable_partition</a>(in, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a &gt;= 4; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ae51c8e542493089f60675db2d0018329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51c8e542493089f60675db2d0018329">&#9670;&nbsp;</a></span>stable_partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::stable_partition </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacerah.html#ac184b21a98515705f9b4845875fb689b" title="Reorders the elements in the range in such a way that all elements for which the predicate pred retur...">rah::stable_partition(R&amp;&amp;, P&amp;&amp;)</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3, 4, 5 };</div><div class="line">        <span class="keyword">auto</span> boundary = in | <a class="code" href="namespacerah.html#ac184b21a98515705f9b4845875fb689b">rah::stable_partition</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a &gt;= 4; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 4, 5, 1, 2, 3 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a215c9f80364af9121e2be42d1ebacdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215c9f80364af9121e2be42d1ebacdbf">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P  = is_lesser, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::stable_sort </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in the range in ascending order. </p>
<p>The order of equivalent elements is guaranteed to be preserved.</p>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>CmpA</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> a;</div><div class="line">        <span class="keywordtype">int</span> b;</div><div class="line">        <span class="keywordtype">bool</span> operator&lt;(CmpA rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            <span class="keywordflow">return</span> a &lt; rhs.a;</div><div class="line">        }</div><div class="line">        <span class="keywordtype">bool</span> <a class="code" href="test_8cpp.html#ab25e26d7469a6dcdb6ac799b640e352b">operator==</a>(CmpA rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword">        </span>{</div><div class="line">            <span class="keywordflow">return</span> a == rhs.a &amp;&amp; b == rhs.b;</div><div class="line">        }</div><div class="line">    };</div><div class="line">    {</div><div class="line">        std::vector&lt;CmpA&gt; in{ { 4, 1 }, { 2, 1 }, { 4, 2 }, { 1, 1 }, { 4, 3 }, { 2, 2 }, { 4, 4 } };</div><div class="line">        <a class="code" href="namespacerah.html#a215c9f80364af9121e2be42d1ebacdbf">rah::stable_sort</a>(in);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;CmpA&gt;({ { 1, 1 }, { 2, 1 }, { 2, 2 }, { 4, 1 }, { 4, 2 }, { 4, 3 }, { 4, 4 } }));</div><div class="line">    }</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;CmpA&gt; in{ { 4, 1 }, { 2, 1 }, { 4, 2 }, { 1, 1 }, { 4, 3 }, { 2, 2 }, { 4, 4 } };</div><div class="line">        <a class="code" href="namespacerah.html#a215c9f80364af9121e2be42d1ebacdbf">rah::stable_sort</a>(in, [](CmpA l, CmpA r) { <span class="keywordflow">return</span> l.b &lt; r.b; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;CmpA&gt;({ { 4, 1 }, { 2, 1 }, { 1, 1 }, { 4, 2 }, { 2, 2 }, { 4, 3 }, { 4, 4 } }));</div></div><!-- fragment -->
</div>
</div>
<a id="aa45a27d7e9403b82624632e1ee3daf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45a27d7e9403b82624632e1ee3daf6f">&#9670;&nbsp;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P  = is_lesser, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::stable_sort </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in the range in ascending order. </p>
<p>The order of equivalent elements is guaranteed to be preserved. </p><dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        in | <a class="code" href="namespacerah.html#a215c9f80364af9121e2be42d1ebacdbf">rah::stable_sort</a>();</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;CmpA&gt;({ { 1, 1 }, { 2, 1 }, { 2, 2 }, { 4, 1 }, { 4, 2 }, { 4, 3 }, { 4, 4 } }));</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;CmpA&gt; in{ { 4, 1 }, { 2, 1 }, { 4, 2 }, { 1, 1 }, { 4, 3 }, { 2, 2 }, { 4, 4 } };</div><div class="line">        in | <a class="code" href="namespacerah.html#a215c9f80364af9121e2be42d1ebacdbf">rah::stable_sort</a>([](CmpA l, CmpA r) { <span class="keywordflow">return</span> l.b &lt; r.b; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;CmpA&gt;({ { 4, 1 }, { 2, 1 }, { 1, 1 }, { 4, 2 }, { 2, 2 }, { 4, 3 }, { 4, 4 } }));</div></div><!-- fragment -->
</div>
</div>
<a id="a3f7b590b1bd8a44b5b2d6f4e35f1837c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7b590b1bd8a44b5b2d6f4e35f1837c">&#9670;&nbsp;</a></span>stream_inserter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::stream_inserter </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a range which output to a stream. </p>
<div class="fragment"><div class="line">        std::string in(<span class="stringliteral">&quot;Test&quot;</span>);</div><div class="line">        std::stringstream out;</div><div class="line">        in | <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(<a class="code" href="namespacerah.html#a3f7b590b1bd8a44b5b2d6f4e35f1837c">rah::stream_inserter</a>(out));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out.str() == in);</div></div><!-- fragment -->
</div>
</div>
<a id="a11fcae12055a2bcf5ac7c41e25e74a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fcae12055a2bcf5ac7c41e25e74a32">&#9670;&nbsp;</a></span>to_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::to_container </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = rah::to_container&lt;std::map&lt;int, char&gt;&gt;(in1);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = rah::to_container&lt;std::vector&lt;int&gt;&gt;(in2);</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aac33763a1f49060e179c2c2053ec07a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac33763a1f49060e179c2c2053ec07a2">&#9670;&nbsp;</a></span>to_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::to_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = in1 | rah::to_container&lt;std::map&lt;int, char&gt;&gt;();</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = in2 | rah::to_container&lt;std::vector&lt;int&gt;&gt;();</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7cb27bf7219a7ee4b47cc9da217810a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb27bf7219a7ee4b47cc9da217810a8">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::transform </td>
          <td>(</td>
          <td class="paramtype">RI &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecOut;</div><div class="line">        <a class="code" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">rah::transform</a>(vecIn1, <a class="code" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">rah::back_inserter</a>(vecOut), [](<span class="keywordtype">int</span> a) {<span class="keywordflow">return</span> a + 1; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(vecOut == std::vector&lt;int&gt;({ 1, 2, 3, 4 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7bac191e66e0d3f3823e0c08382f0418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bac191e66e0d3f3823e0c08382f0418">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::transform </td>
          <td>(</td>
          <td class="paramtype">RI1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RI2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary operation binary_op is applied to pairs of elements from two ranges. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecIn2{ 4, 3, 2, 1 };</div><div class="line">        std::vector&lt;int&gt; vecOut;</div><div class="line">        <a class="code" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">rah::transform</a>(vecIn1, vecIn2, <a class="code" href="namespacerah.html#a0698f952bc3c4f1961929bbddb5812fe">rah::back_inserter</a>(vecOut), [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {<span class="keywordflow">return</span> a + b; });</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(vecOut == std::vector&lt;int&gt;({ 4, 4, 4, 4 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7c4f0afb068c908600b357e111148df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4f0afb068c908600b357e111148df7">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P  = is_equal, typename  = std ::enable_if_t&lt;is_range&lt;R&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::unique </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all but first successuve values which are equals. </p>
<p>Without resizing the range. </p><dl class="section return"><dt>Returns</dt><dd>The end part of the range, which have to be remove.</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 1, 1, 5, 3, 3, 4 };</div><div class="line">        in.erase(<a class="code" href="namespacerah.html#a7c4f0afb068c908600b357e111148df7">rah::unique</a>(in), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 2, 1, 5, 3, 4 }));</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 1, 1, 5, 3, 3, 4 };</div><div class="line">        in.erase(<a class="code" href="namespacerah.html#a7c4f0afb068c908600b357e111148df7">rah::unique</a>(in, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a == b; }), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 2, 1, 5, 3, 4 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aafbbb6f9bd014675985d33d93221acca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbbb6f9bd014675985d33d93221acca">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P  = is_equal, typename  = std ::enable_if_t&lt;not is_range&lt;P&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::unique </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all but first successuve values which are equals. </p>
<p>Without resizing the range. </p><dl class="section return"><dt>Returns</dt><dd>The end part of the range, which have to be remove. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 1, 1, 5, 3, 3, 4 };</div><div class="line">        in.erase(in | <a class="code" href="namespacerah.html#a7c4f0afb068c908600b357e111148df7">rah::unique</a>(), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 2, 1, 5, 3, 4 }));</div></div><!-- fragment --><div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 2, 1, 1, 1, 5, 3, 3, 4 };</div><div class="line">        in.erase(in | <a class="code" href="namespacerah.html#a7c4f0afb068c908600b357e111148df7">rah::unique</a>([](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a == b; }), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(in));</div><div class="line">        <a class="code" href="test_8cpp.html#a697b813778d7c62ced8c21c69291b30a">assert</a>(in == std::vector&lt;int&gt;({ 2, 1, 5, 3, 4 }));</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5af06eebbd592c36368022990839b982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af06eebbd592c36368022990839b982">&#9670;&nbsp;</a></span>End</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr intptr_t rah::End = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used with <a class="el" href="namespacerah_1_1view.html#a26e48a024bda08769061de4ad6addd9c" title="Create a view that is a sub-range of a range.">rah::view::slice</a> to point to the end. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
