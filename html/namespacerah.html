<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rah: rah Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rah
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rah Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerah_1_1view"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah_1_1view.html">view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade.html">iterator_facade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make an iterator.  <a href="structrah_1_1iterator__facade.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1bidirectional__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a bidirectional iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1bidirectional__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1forward__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::forward_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a forward_iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1forward__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1random__access__iterator__tag_01_4.html">iterator_facade&lt; I, R, std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inerit to make a random access iterator.  <a href="structrah_1_1iterator__facade_3_01_i_00_01_r_00_01std_1_1random__access__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrah_1_1pipeable.html">pipeable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow to call a custom function when called whith the 'pipe' syntax on a range.  <a href="structrah_1_1pipeable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a> = decltype(<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a28aff4eeddcece6be65ff0b956d32d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9657e24ae477f4482225b133fe286b65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9657e24ae477f4482225b133fe286b65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a9657e24ae477f4482225b133fe286b65">range_end_type_t</a> = decltype(<a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a9657e24ae477f4482225b133fe286b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6622426bea22e9509614fe4c574ebeca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6622426bea22e9509614fe4c574ebeca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a> = decltype(*<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt; T &gt;()))</td></tr>
<tr class="separator:a6622426bea22e9509614fe4c574ebeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b32e39fb106af7036b20a39c4f024c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b32e39fb106af7036b20a39c4f024c1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4b32e39fb106af7036b20a39c4f024c1">range_value_type_t</a> = std::remove_reference_t&lt; <a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a4b32e39fb106af7036b20a39c4f024c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9b9a5748e293f6a1726308c1ac1a01"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aff9b9a5748e293f6a1726308c1ac1a01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aff9b9a5748e293f6a1726308c1ac1a01">range_iter_categ_t</a> = typename std::iterator_traits&lt; <a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a>&lt; R &gt; &gt;::iterator_category</td></tr>
<tr class="separator:aff9b9a5748e293f6a1726308c1ac1a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11785bbdf970efa1bc57fc14993b77bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11785bbdf970efa1bc57fc14993b77bf"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a> ()</td></tr>
<tr class="separator:a11785bbdf970efa1bc57fc14993b77bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4e145bfeb8a932058e20fc4cb4e7c206">make_iterator_range</a> (I b, I e)</td></tr>
<tr class="memdesc:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structrah_1_1iterator__range.html">rah::iterator_range</a> with two given iterators.  <a href="#a4e145bfeb8a932058e20fc4cb4e7c206">More...</a><br /></td></tr>
<tr class="separator:a4e145bfeb8a932058e20fc4cb4e7c206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a19e57cc4e0753e93830f247def6d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a2c4a19e57cc4e0753e93830f247def6d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="memdesc:a2c4a19e57cc4e0753e93830f247def6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator of the range.  <a href="#a2c4a19e57cc4e0753e93830f247def6d">More...</a><br /></td></tr>
<tr class="separator:a2c4a19e57cc4e0753e93830f247def6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddd1442cd76b96876e692cdefe7261d"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:aaddd1442cd76b96876e692cdefe7261d"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;r)</td></tr>
<tr class="memdesc:aaddd1442cd76b96876e692cdefe7261d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "past the" end iterator of the range.  <a href="#aaddd1442cd76b96876e692cdefe7261d">More...</a><br /></td></tr>
<tr class="separator:aaddd1442cd76b96876e692cdefe7261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e69321e6772651b349cb31467ea3a2"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a14e69321e6772651b349cb31467ea3a2"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a14e69321e6772651b349cb31467ea3a2">begin</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="memdesc:a14e69321e6772651b349cb31467ea3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the begin iterator of the range.  <a href="#a14e69321e6772651b349cb31467ea3a2">More...</a><br /></td></tr>
<tr class="separator:a14e69321e6772651b349cb31467ea3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31fe80bf81abf3149df010cb265e20"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a6b31fe80bf81abf3149df010cb265e20"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6b31fe80bf81abf3149df010cb265e20">end</a> (<a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;r)</td></tr>
<tr class="memdesc:a6b31fe80bf81abf3149df010cb265e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "past the" end iterator of the range.  <a href="#a6b31fe80bf81abf3149df010cb265e20">More...</a><br /></td></tr>
<tr class="separator:a6b31fe80bf81abf3149df010cb265e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274b78c4c0af5dd58ce280f02223fb55"><td class="memTemplParams" colspan="2">template&lt;typename MakeRange &gt; </td></tr>
<tr class="memitem:a274b78c4c0af5dd58ce280f02223fb55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a274b78c4c0af5dd58ce280f02223fb55">make_pipeable</a> (MakeRange &amp;&amp;make_range)</td></tr>
<tr class="memdesc:a274b78c4c0af5dd58ce280f02223fb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to create a "pipeable" function (UFCS style in c++)  <a href="#a274b78c4c0af5dd58ce280f02223fb55">More...</a><br /></td></tr>
<tr class="separator:a274b78c4c0af5dd58ce280f02223fb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6923b0ef49c831571590f953253ff9"><td class="memTemplParams" colspan="2">template&lt;typename R , typename MakeRange &gt; </td></tr>
<tr class="memitem:a5c6923b0ef49c831571590f953253ff9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a5c6923b0ef49c831571590f953253ff9">operator|</a> (R &amp;&amp;range, <a class="el" href="structrah_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;adapter)</td></tr>
<tr class="separator:a5c6923b0ef49c831571590f953253ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51feb1497566c28de396f50735fd259b"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a51feb1497566c28de396f50735fd259b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">empty</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a51feb1497566c28de396f50735fd259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the range if empty.  <a href="#a51feb1497566c28de396f50735fd259b">More...</a><br /></td></tr>
<tr class="separator:a51feb1497566c28de396f50735fd259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6ceb90c934b1c4927ab4e08b985ef6c5">empty</a> ()</td></tr>
<tr class="memdesc:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the range if empty.  <a href="#a6ceb90c934b1c4927ab4e08b985ef6c5">More...</a><br /></td></tr>
<tr class="separator:a6ceb90c934b1c4927ab4e08b985ef6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memTemplParams" colspan="2">template&lt;typename RI , typename RO , typename F &gt; </td></tr>
<tr class="memitem:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">transform</a> (RI &amp;&amp;rangeIn, RO &amp;&amp;rangeOut, F &amp;&amp;unary_op)</td></tr>
<tr class="memdesc:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut.  <a href="#a7cb27bf7219a7ee4b47cc9da217810a8">More...</a><br /></td></tr>
<tr class="separator:a7cb27bf7219a7ee4b47cc9da217810a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bac191e66e0d3f3823e0c08382f0418"><td class="memTemplParams" colspan="2">template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </td></tr>
<tr class="memitem:a7bac191e66e0d3f3823e0c08382f0418"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7bac191e66e0d3f3823e0c08382f0418">transform</a> (RI1 &amp;&amp;rangeIn1, RI2 &amp;&amp;rangeIn2, RO &amp;&amp;rangeOut, F &amp;&amp;binary_op)</td></tr>
<tr class="memdesc:a7bac191e66e0d3f3823e0c08382f0418"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary operation binary_op is applied to pairs of elements from two ranges.  <a href="#a7bac191e66e0d3f3823e0c08382f0418">More...</a><br /></td></tr>
<tr class="separator:a7bac191e66e0d3f3823e0c08382f0418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename F &gt; </td></tr>
<tr class="memitem:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">reduce</a> (R &amp;&amp;range, I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#a407b50a4f029e3f2a3cd0ba9142aea84">More...</a><br /></td></tr>
<tr class="separator:a407b50a4f029e3f2a3cd0ba9142aea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a6a6b7b7e3b78bb4bd16372fbb688c152">reduce</a> (I &amp;&amp;init, F &amp;&amp;reducer)</td></tr>
<tr class="memdesc:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a reducer function on each element of the range, resulting in a single output value.  <a href="#a6a6b7b7e3b78bb4bd16372fbb688c152">More...</a><br /></td></tr>
<tr class="separator:a6a6b7b7e3b78bb4bd16372fbb688c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836c57da2bd108c491f3ba96786f6aa4"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a836c57da2bd108c491f3ba96786f6aa4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">any_of</a> (R &amp;&amp;range, F &amp;&amp;pred)</td></tr>
<tr class="memdesc:a836c57da2bd108c491f3ba96786f6aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#a836c57da2bd108c491f3ba96786f6aa4">More...</a><br /></td></tr>
<tr class="separator:a836c57da2bd108c491f3ba96786f6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa3f330b2354859d8a9e6df794a1e7a1a">any_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for at least one element in the range.  <a href="#aa3f330b2354859d8a9e6df794a1e7a1a">More...</a><br /></td></tr>
<tr class="separator:aa3f330b2354859d8a9e6df794a1e7a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">all_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#aaf7abb6066c8adfe6959691c3a3ea4e2">More...</a><br /></td></tr>
<tr class="separator:aaf7abb6066c8adfe6959691c3a3ea4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4066165c960917a330beeed75a0f96e7"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a4066165c960917a330beeed75a0f96e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a4066165c960917a330beeed75a0f96e7">all_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a4066165c960917a330beeed75a0f96e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for all elements in the range.  <a href="#a4066165c960917a330beeed75a0f96e7">More...</a><br /></td></tr>
<tr class="separator:a4066165c960917a330beeed75a0f96e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">none_of</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#a2a3ff8b7f73d480ac0827f9a41a3c92a">More...</a><br /></td></tr>
<tr class="separator:a2a3ff8b7f73d480ac0827f9a41a3c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa05e58774ee8e9e05cd3e6ed2a2fa372">none_of</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate pred returns true for no elements in the range.  <a href="#aa05e58774ee8e9e05cd3e6ed2a2fa372">More...</a><br /></td></tr>
<tr class="separator:aa05e58774ee8e9e05cd3e6ed2a2fa372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa528865cc4a45d4eb276329554f16b4b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:aa528865cc4a45d4eb276329554f16b4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">count</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:aa528865cc4a45d4eb276329554f16b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#aa528865cc4a45d4eb276329554f16b4b">More...</a><br /></td></tr>
<tr class="separator:aa528865cc4a45d4eb276329554f16b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8400202fc4005dbade0f479dd556ec3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae8400202fc4005dbade0f479dd556ec3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ae8400202fc4005dbade0f479dd556ec3">count</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:ae8400202fc4005dbade0f479dd556ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the elements that are equal to value.  <a href="#ae8400202fc4005dbade0f479dd556ec3">More...</a><br /></td></tr>
<tr class="separator:ae8400202fc4005dbade0f479dd556ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6a379c05d482a52137f5647783fe27"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a8e6a379c05d482a52137f5647783fe27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">count_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a8e6a379c05d482a52137f5647783fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#a8e6a379c05d482a52137f5647783fe27">More...</a><br /></td></tr>
<tr class="separator:a8e6a379c05d482a52137f5647783fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e22b56a1f28a353659fed572f33f5a9"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a9e22b56a1f28a353659fed572f33f5a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a9e22b56a1f28a353659fed572f33f5a9">count_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a9e22b56a1f28a353659fed572f33f5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements for which predicate pred returns true.  <a href="#a9e22b56a1f28a353659fed572f33f5a9">More...</a><br /></td></tr>
<tr class="separator:a9e22b56a1f28a353659fed572f33f5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6ed477fd9ab2f873d76a4b50ffac39"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:afe6ed477fd9ab2f873d76a4b50ffac39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#afe6ed477fd9ab2f873d76a4b50ffac39">for_each</a> (R &amp;&amp;range, F &amp;&amp;func)</td></tr>
<tr class="memdesc:afe6ed477fd9ab2f873d76a4b50ffac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#afe6ed477fd9ab2f873d76a4b50ffac39">More...</a><br /></td></tr>
<tr class="separator:afe6ed477fd9ab2f873d76a4b50ffac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a76e2ce1a497aa3726cc9d99fb320ac67">for_each</a> (F &amp;&amp;func)</td></tr>
<tr class="memdesc:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given function func to each element of the range.  <a href="#a76e2ce1a497aa3726cc9d99fb320ac67">More...</a><br /></td></tr>
<tr class="separator:a76e2ce1a497aa3726cc9d99fb320ac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R &gt; </td></tr>
<tr class="memitem:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a11fcae12055a2bcf5ac7c41e25e74a32">to_container</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#a11fcae12055a2bcf5ac7c41e25e74a32">More...</a><br /></td></tr>
<tr class="separator:a11fcae12055a2bcf5ac7c41e25e74a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac33763a1f49060e179c2c2053ec07a2"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aac33763a1f49060e179c2c2053ec07a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#aac33763a1f49060e179c2c2053ec07a2">to_container</a> ()</td></tr>
<tr class="memdesc:aac33763a1f49060e179c2c2053ec07a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a container of type C, filled with the content of range.  <a href="#aac33763a1f49060e179c2c2053ec07a2">More...</a><br /></td></tr>
<tr class="separator:aac33763a1f49060e179c2c2053ec07a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a5ce2d92c6f0b3dd5eb6d70600e949a97">mismatch</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first position where two ranges differ.  <a href="#a5ce2d92c6f0b3dd5eb6d70600e949a97">More...</a><br /></td></tr>
<tr class="separator:a5ce2d92c6f0b3dd5eb6d70600e949a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7d4f08068e85923f475a069c3daeb7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename V &gt; </td></tr>
<tr class="memitem:a7c7d4f08068e85923f475a069c3daeb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">find</a> (R &amp;&amp;range, V &amp;&amp;value)</td></tr>
<tr class="memdesc:a7c7d4f08068e85923f475a069c3daeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a7c7d4f08068e85923f475a069c3daeb7">More...</a><br /></td></tr>
<tr class="separator:a7c7d4f08068e85923f475a069c3daeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f60e134164914703fdd0508f83ee11"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a37f60e134164914703fdd0508f83ee11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a37f60e134164914703fdd0508f83ee11">find</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a37f60e134164914703fdd0508f83ee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element equal to value.  <a href="#a37f60e134164914703fdd0508f83ee11">More...</a><br /></td></tr>
<tr class="separator:a37f60e134164914703fdd0508f83ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd71a185a2510e691dcd715a31edf53"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:acbd71a185a2510e691dcd715a31edf53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">find_if</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:acbd71a185a2510e691dcd715a31edf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#acbd71a185a2510e691dcd715a31edf53">More...</a><br /></td></tr>
<tr class="separator:acbd71a185a2510e691dcd715a31edf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04200b08ecdef8daf99f04c58f29e459"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a04200b08ecdef8daf99f04c58f29e459"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a04200b08ecdef8daf99f04c58f29e459">find_if</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a04200b08ecdef8daf99f04c58f29e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying specific criteria.  <a href="#a04200b08ecdef8daf99f04c58f29e459">More...</a><br /></td></tr>
<tr class="separator:a04200b08ecdef8daf99f04c58f29e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af758ef3c67d20ba6260319cb0e0171c5"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:af758ef3c67d20ba6260319cb0e0171c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">find_if_not</a> (R &amp;&amp;range, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:af758ef3c67d20ba6260319cb0e0171c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#af758ef3c67d20ba6260319cb0e0171c5">More...</a><br /></td></tr>
<tr class="separator:af758ef3c67d20ba6260319cb0e0171c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a406c37a2cf758e7329bfd696a6bf8f89">find_if_not</a> (P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a406c37a2cf758e7329bfd696a6bf8f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element not satisfying specific criteria.  <a href="#a406c37a2cf758e7329bfd696a6bf8f89">More...</a><br /></td></tr>
<tr class="separator:a406c37a2cf758e7329bfd696a6bf8f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0f36ff683cedc9090956ea389b3312"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a1d0f36ff683cedc9090956ea389b3312"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">copy</a> (R1 &amp;&amp;in, R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:a1d0f36ff683cedc9090956ea389b3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in range into an other.  <a href="#a1d0f36ff683cedc9090956ea389b3312">More...</a><br /></td></tr>
<tr class="separator:a1d0f36ff683cedc9090956ea389b3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c29fa208b4ab8bfb9c226a1f82b9a1"><td class="memTemplParams" colspan="2">template&lt;typename R2 &gt; </td></tr>
<tr class="memitem:ad9c29fa208b4ab8bfb9c226a1f82b9a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#ad9c29fa208b4ab8bfb9c226a1f82b9a1">copy_into</a> (R2 &amp;&amp;out)</td></tr>
<tr class="memdesc:ad9c29fa208b4ab8bfb9c226a1f82b9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy in range into an other.  <a href="#ad9c29fa208b4ab8bfb9c226a1f82b9a1">More...</a><br /></td></tr>
<tr class="separator:ad9c29fa208b4ab8bfb9c226a1f82b9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85af749badb4261aa3c97a1d98134493"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a85af749badb4261aa3c97a1d98134493"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">size</a> (R &amp;&amp;range)</td></tr>
<tr class="memdesc:a85af749badb4261aa3c97a1d98134493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#a85af749badb4261aa3c97a1d98134493">More...</a><br /></td></tr>
<tr class="separator:a85af749badb4261aa3c97a1d98134493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerah.html#aaee48fa7a804b4fd19c6a78bdd8d4c85">size</a> ()</td></tr>
<tr class="memdesc:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of range.  <a href="#aaee48fa7a804b4fd19c6a78bdd8d4c85">More...</a><br /></td></tr>
<tr class="separator:aaee48fa7a804b4fd19c6a78bdd8d4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">equal</a> (R1 &amp;&amp;range1, R2 &amp;&amp;range2)</td></tr>
<tr class="memdesc:abf321dffb33d6a2d752aa091fdba7bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two sets of elements are the same.  <a href="#abf321dffb33d6a2d752aa091fdba7bbf">More...</a><br /></td></tr>
<tr class="separator:abf321dffb33d6a2d752aa091fdba7bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3434aacc26937d3ff50b5db4286feda6"><td class="memTemplParams" colspan="2">template&lt;typename R1 &gt; </td></tr>
<tr class="memitem:a3434aacc26937d3ff50b5db4286feda6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerah.html#a3434aacc26937d3ff50b5db4286feda6">equal</a> (R1 &amp;&amp;range2)</td></tr>
<tr class="memdesc:a3434aacc26937d3ff50b5db4286feda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two sets of elements are the same.  <a href="#a3434aacc26937d3ff50b5db4286feda6">More...</a><br /></td></tr>
<tr class="separator:a3434aacc26937d3ff50b5db4286feda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a28aff4eeddcece6be65ff0b956d32d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aff4eeddcece6be65ff0b956d32d4a">&#9670;&nbsp;</a></span>range_begin_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">rah::range_begin_type_t</a> = typedef decltype(<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9657e24ae477f4482225b133fe286b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9657e24ae477f4482225b133fe286b65">&#9670;&nbsp;</a></span>range_end_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a9657e24ae477f4482225b133fe286b65">rah::range_end_type_t</a> = typedef decltype(<a class="el" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff9b9a5748e293f6a1726308c1ac1a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9b9a5748e293f6a1726308c1ac1a01">&#9670;&nbsp;</a></span>range_iter_categ_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#aff9b9a5748e293f6a1726308c1ac1a01">rah::range_iter_categ_t</a> = typedef typename std::iterator_traits&lt;<a class="el" href="namespacerah.html#a28aff4eeddcece6be65ff0b956d32d4a">range_begin_type_t</a>&lt;R&gt; &gt;::iterator_category</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6622426bea22e9509614fe4c574ebeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6622426bea22e9509614fe4c574ebeca">&#9670;&nbsp;</a></span>range_ref_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">rah::range_ref_type_t</a> = typedef decltype(*<a class="el" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(<a class="el" href="namespacerah.html#a11785bbdf970efa1bc57fc14993b77bf">fake</a>&lt;T&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b32e39fb106af7036b20a39c4f024c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b32e39fb106af7036b20a39c4f024c1">&#9670;&nbsp;</a></span>range_value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacerah.html#a4b32e39fb106af7036b20a39c4f024c1">rah::range_value_type_t</a> = typedef std::remove_reference_t&lt;<a class="el" href="namespacerah.html#a6622426bea22e9509614fe4c574ebeca">range_ref_type_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf7abb6066c8adfe6959691c3a3ea4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7abb6066c8adfe6959691c3a3ea4e2">&#9670;&nbsp;</a></span>all_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::all_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">rah::all_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 4, 4 }, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="a4066165c960917a330beeed75a0f96e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4066165c960917a330beeed75a0f96e7">&#9670;&nbsp;</a></span>all_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::all_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for all elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{ 4, 4, 3, 4 } </div><div class="line">        | <a class="code" href="namespacerah.html#aaf7abb6066c8adfe6959691c3a3ea4e2">rah::all_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; })</div><div class="line">    ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a836c57da2bd108c491f3ba96786f6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836c57da2bd108c491f3ba96786f6aa4">&#9670;&nbsp;</a></span>any_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::any_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">rah::any_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{ 3, 0, 1, 3, 4, 6 }, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">    );</div></div><!-- fragment -->
</div>
</div>
<a id="aa3f330b2354859d8a9e6df794a1e7a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f330b2354859d8a9e6df794a1e7a1a">&#9670;&nbsp;</a></span>any_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::any_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for at least one element in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{0, 1, 2, 3, 4, 6}</div><div class="line">        | <a class="code" href="namespacerah.html#a836c57da2bd108c491f3ba96786f6aa4">rah::any_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })</div><div class="line">    ));</div></div><!-- fragment -->
</div>
</div>
<a id="a2c4a19e57cc4e0753e93830f247def6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4a19e57cc4e0753e93830f247def6d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the begin iterator of the range. </p>

</div>
</div>
<a id="a14e69321e6772651b349cb31467ea3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e69321e6772651b349cb31467ea3a2">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the begin iterator of the range. </p>

</div>
</div>
<a id="a1d0f36ff683cedc9090956ea389b3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0f36ff683cedc9090956ea389b3312">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in range into an other. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        assert(<a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">rah::copy</a>(in, out) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 4, 5 })));</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="ad9c29fa208b4ab8bfb9c226a1f82b9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c29fa208b4ab8bfb9c226a1f82b9a1">&#9670;&nbsp;</a></span>copy_into()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::copy_into </td>
          <td>(</td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy in range into an other. </p>
<dl class="section return"><dt>Returns</dt><dd>The part of out after the copied part </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; out{ 0, 0, 0, 4, 5 };</div><div class="line">        assert((in | <a class="code" href="namespacerah.html#ad9c29fa208b4ab8bfb9c226a1f82b9a1">rah::copy_into</a>(out) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 4, 5 }))));</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aa528865cc4a45d4eb276329554f16b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa528865cc4a45d4eb276329554f16b4b">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">rah::count</a>(std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 }, 3) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="ae8400202fc4005dbade0f479dd556ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8400202fc4005dbade0f479dd556ec3">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the elements that are equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">rah::count</a>(4)) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a8e6a379c05d482a52137f5647783fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6a379c05d482a52137f5647783fe27">&#9670;&nbsp;</a></span>count_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert(<a class="code" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">rah::count_if</a>(il&lt;int&gt;{ 4, 4, 4, 3 }, [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 4; }) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a9e22b56a1f28a353659fed572f33f5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e22b56a1f28a353659fed572f33f5a9">&#9670;&nbsp;</a></span>count_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::count_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements for which predicate pred returns true. </p>
<div class="fragment"><div class="line">    assert((std::initializer_list&lt;int&gt;{ 4, 4, 4, 3 } | <a class="code" href="namespacerah.html#a8e6a379c05d482a52137f5647783fe27">rah::count_if</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 3; })) == 1);</div></div><!-- fragment -->
</div>
</div>
<a id="a51feb1497566c28de396f50735fd259b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51feb1497566c28de396f50735fd259b">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::empty </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the range if empty. </p>
<div class="fragment"><div class="line">    assert(not (<a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>(std::vector&lt;int&gt;{ 1, 2, 3 })));</div><div class="line">    assert(<a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>(std::vector&lt;int&gt;()));</div></div><!-- fragment -->
</div>
</div>
<a id="a6ceb90c934b1c4927ab4e08b985ef6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb90c934b1c4927ab4e08b985ef6c5">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto rah::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the range if empty. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert(not (std::vector&lt;int&gt;{ 1, 2, 3 } | <a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>()));</div><div class="line">    assert(std::vector&lt;int&gt;() | <a class="code" href="namespacerah.html#a51feb1497566c28de396f50735fd259b">rah::empty</a>());</div></div><!-- fragment -->
</div>
</div>
<a id="aaddd1442cd76b96876e692cdefe7261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddd1442cd76b96876e692cdefe7261d">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "past the" end iterator of the range. </p>

</div>
</div>
<a id="a6b31fe80bf81abf3149df010cb265e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31fe80bf81abf3149df010cb265e20">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I rah::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrah_1_1iterator__range.html">iterator_range</a>&lt; I &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "past the" end iterator of the range. </p>

</div>
</div>
<a id="abf321dffb33d6a2d752aa091fdba7bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf321dffb33d6a2d752aa091fdba7bbf">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two sets of elements are the same. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in3{ 11, 12, 13 };</div><div class="line">        assert(<a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in1, in2));</div><div class="line">        assert(<a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in1, in3) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a3434aacc26937d3ff50b5db4286feda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3434aacc26937d3ff50b5db4286feda6">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::equal </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two sets of elements are the same. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in2{ 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; in3{ 11, 12, 13 };</div><div class="line">        assert(in1 | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in2));</div><div class="line">        assert(not (in1 | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(in3)));</div></div><!-- fragment -->
</div>
</div>
<a id="a11785bbdf970efa1bc57fc14993b77bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11785bbdf970efa1bc57fc14993b77bf">&#9670;&nbsp;</a></span>fake()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; rah::fake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7d4f08068e85923f475a069c3daeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7d4f08068e85923f475a069c3daeb7">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">rah::find</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, 3) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({3, 4})))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a37f60e134164914703fdd0508f83ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f60e134164914703fdd0508f83ee11">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element equal to value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespacerah.html#a7c7d4f08068e85923f475a069c3daeb7">rah::find</a>(3) | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="acbd71a185a2510e691dcd715a31edf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd71a185a2510e691dcd715a31edf53">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">rah::find_if</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; }) </div><div class="line">                | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a04200b08ecdef8daf99f04c58f29e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04200b08ecdef8daf99f04c58f29e459">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespacerah.html#acbd71a185a2510e691dcd715a31edf53">rah::find_if</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i == 3; }) </div><div class="line">                | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="af758ef3c67d20ba6260319cb0e0171c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af758ef3c67d20ba6260319cb0e0171c5">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if_not </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (<a class="code" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">rah::find_if_not</a>(std::vector&lt;int&gt;{ 1, 2, 3, 4 }, [](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; }) </div><div class="line">                | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="a406c37a2cf758e7329bfd696a6bf8f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406c37a2cf758e7329bfd696a6bf8f89">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::find_if_not </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element not satisfying specific criteria. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        assert(</div><div class="line">            (std::vector&lt;int&gt;{ 1, 2, 3, 4 } | <a class="code" href="namespacerah.html#af758ef3c67d20ba6260319cb0e0171c5">rah::find_if_not</a>([](<span class="keywordtype">int</span> i) {<span class="keywordflow">return</span> i &lt; 3; }) </div><div class="line">                | <a class="code" href="namespacerah.html#abf321dffb33d6a2d752aa091fdba7bbf">rah::equal</a>(std::initializer_list&lt;int&gt;({ 3, 4 })))</div><div class="line">        );</div></div><!-- fragment -->
</div>
</div>
<a id="afe6ed477fd9ab2f873d76a4b50ffac39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6ed477fd9ab2f873d76a4b50ffac39">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rah::for_each </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        <a class="code" href="namespacerah.html#afe6ed477fd9ab2f873d76a4b50ffac39">rah::for_each</a>(testFE, [](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        EQUAL_RANGE(testFE, il&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a76e2ce1a497aa3726cc9d99fb320ac67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2ce1a497aa3726cc9d99fb320ac67">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function func to each element of the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; testFE{ 4, 4, 4, 4 };</div><div class="line">        testFE | <a class="code" href="namespacerah.html#afe6ed477fd9ab2f873d76a4b50ffac39">rah::for_each</a>([](<span class="keyword">auto</span>&amp; value) {<span class="keywordflow">return</span> ++value; });</div><div class="line">        EQUAL_RANGE(testFE, il&lt;int&gt;({ 5, 5, 5, 5 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a4e145bfeb8a932058e20fc4cb4e7c206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e145bfeb8a932058e20fc4cb4e7c206">&#9670;&nbsp;</a></span>make_iterator_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rah::make_iterator_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structrah_1_1iterator__range.html">rah::iterator_range</a> with two given iterators. </p>

</div>
</div>
<a id="a274b78c4c0af5dd58ce280f02223fb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b78c4c0af5dd58ce280f02223fb55">&#9670;&nbsp;</a></span>make_pipeable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rah::make_pipeable </td>
          <td>(</td>
          <td class="paramtype">MakeRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>make_range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to create a "pipeable" function (UFCS style in c++) </p>
<h1><a class="anchor" id="create_pipeable"></a>
How to create :</h1>
<div class="fragment"><div class="line"><span class="keyword">auto</span> test_count(<span class="keywordtype">int</span> i)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacerah.html#a274b78c4c0af5dd58ce280f02223fb55">rah::make_pipeable</a>([=](<span class="keyword">auto</span>&amp;&amp; range) { <span class="keywordflow">return</span> <a class="code" href="namespacerah.html#aa528865cc4a45d4eb276329554f16b4b">std::count</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(range), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(range), i); });</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="use_pipeable"></a>
How to use :</h1>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec{ 0, 1, 2, 2, 3 };</div><div class="line">        assert((vec | test_count(2)) == 2);</div></div><!-- fragment -->
</div>
</div>
<a id="a5ce2d92c6f0b3dd5eb6d70600e949a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce2d92c6f0b3dd5eb6d70600e949a97">&#9670;&nbsp;</a></span>mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::mismatch </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>range2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first position where two ranges differ. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; in1 = { 1, 2, 3, 4 };</div><div class="line">        std::vector&lt;int&gt; in2 = { 1, 2, 42, 42 };</div><div class="line">        <span class="keyword">auto</span> r1_r2 = <a class="code" href="namespacerah.html#a5ce2d92c6f0b3dd5eb6d70600e949a97">rah::mismatch</a>(in1, in2);</div><div class="line">        std::vector&lt;int&gt; out1;</div><div class="line">        std::vector&lt;int&gt; out2;</div><div class="line">        <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">std::copy</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(std::get&lt;0&gt;(r1_r2)), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(std::get&lt;0&gt;(r1_r2)), std::back_inserter(out1));</div><div class="line">        <a class="code" href="namespacerah.html#a1d0f36ff683cedc9090956ea389b3312">std::copy</a>(<a class="code" href="namespacerah.html#a2c4a19e57cc4e0753e93830f247def6d">begin</a>(std::get&lt;1&gt;(r1_r2)), <a class="code" href="namespacerah.html#aaddd1442cd76b96876e692cdefe7261d">end</a>(std::get&lt;1&gt;(r1_r2)), std::back_inserter(out2));</div><div class="line">        assert(out1 == std::vector&lt;int&gt;({ 3, 4 }));</div><div class="line">        assert(out2 == std::vector&lt;int&gt;({ 42, 42 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a2a3ff8b7f73d480ac0827f9a41a3c92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ff8b7f73d480ac0827f9a41a3c92a">&#9670;&nbsp;</a></span>none_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool rah::none_of </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<div class="fragment"><div class="line">    assert((<a class="code" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">rah::none_of</a>(</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10}, </div><div class="line">        [](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">    ));</div></div><!-- fragment -->
</div>
</div>
<a id="aa05e58774ee8e9e05cd3e6ed2a2fa372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05e58774ee8e9e05cd3e6ed2a2fa372">&#9670;&nbsp;</a></span>none_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::none_of </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate pred returns true for no elements in the range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">    assert((</div><div class="line">        std::initializer_list&lt;int&gt;{7, 8, 9, 10, 11} </div><div class="line">        | <a class="code" href="namespacerah.html#a2a3ff8b7f73d480ac0827f9a41a3c92a">rah::none_of</a>([](<span class="keyword">auto</span> a) {<span class="keywordflow">return</span> a == 11; })</div><div class="line">    ) == <span class="keyword">false</span>);</div></div><!-- fragment -->
</div>
</div>
<a id="a5c6923b0ef49c831571590f953253ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6923b0ef49c831571590f953253ff9">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename MakeRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::operator| </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrah_1_1pipeable.html">pipeable</a>&lt; MakeRange &gt; const &amp;&#160;</td>
          <td class="paramname"><em>adapter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a407b50a4f029e3f2a3cd0ba9142aea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407b50a4f029e3f2a3cd0ba9142aea84">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::reduce </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        assert(<a class="code" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">rah::reduce</a>(vecIn1, 0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; }) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="a6a6b7b7e3b78bb4bd16372fbb688c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6b7b7e3b78bb4bd16372fbb688c152">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::reduce </td>
          <td>(</td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a reducer function on each element of the range, resulting in a single output value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 1, 2, 3, 4 };</div><div class="line">        assert((vecIn1 | <a class="code" href="namespacerah.html#a407b50a4f029e3f2a3cd0ba9142aea84">rah::reduce</a>(0, [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) {<span class="keywordflow">return</span> a + b; })) == 10);</div></div><!-- fragment -->
</div>
</div>
<a id="a85af749badb4261aa3c97a1d98134493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85af749badb4261aa3c97a1d98134493">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::size </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        assert(<a class="code" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">rah::size</a>(vec3) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="aaee48fa7a804b4fd19c6a78bdd8d4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee48fa7a804b4fd19c6a78bdd8d4c85">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto rah::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vec3{ 1, 2, 3 };</div><div class="line">        assert((vec3 | <a class="code" href="namespacerah.html#a85af749badb4261aa3c97a1d98134493">rah::size</a>()) == 3);</div></div><!-- fragment -->
</div>
</div>
<a id="a11fcae12055a2bcf5ac7c41e25e74a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fcae12055a2bcf5ac7c41e25e74a32">&#9670;&nbsp;</a></span>to_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::to_container </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = rah::to_container&lt;std::map&lt;int, char&gt;&gt;(in1);</div><div class="line">        assert(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = rah::to_container&lt;std::vector&lt;int&gt;&gt;(in2);</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="aac33763a1f49060e179c2c2053ec07a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac33763a1f49060e179c2c2053ec07a2">&#9670;&nbsp;</a></span>to_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::to_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a container of type C, filled with the content of range. </p>
<dl class="section remark"><dt>Remarks</dt><dd>pipeable syntax</dd></dl>
<div class="fragment"><div class="line">        std::vector&lt;std::pair&lt;int, char&gt;&gt; in1{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } };</div><div class="line">        std::map&lt;int, char&gt; map_4a_5b_6c_7d = in1 | rah::to_container&lt;std::map&lt;int, char&gt;&gt;();</div><div class="line">        assert(</div><div class="line">            map_4a_5b_6c_7d == (std::map&lt;int, char&gt;{ {4, <span class="charliteral">&#39;a&#39;</span>}, { 5, <span class="charliteral">&#39;b&#39;</span> }, { 6, <span class="charliteral">&#39;c&#39;</span> }, { 7, <span class="charliteral">&#39;d&#39;</span> } })</div><div class="line">        );</div><div class="line"></div><div class="line">        std::list&lt;int&gt; in2{ 4, 5, 6, 7 };</div><div class="line">        std::vector&lt;int&gt; out = in2 | rah::to_container&lt;std::vector&lt;int&gt;&gt;();</div><div class="line">        assert(out == (std::vector&lt;int&gt;{ 4, 5, 6, 7 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7cb27bf7219a7ee4b47cc9da217810a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb27bf7219a7ee4b47cc9da217810a8">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::transform </td>
          <td>(</td>
          <td class="paramtype">RI &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given function unary_op to the range rangeIn and stores the result in the range rangeOut. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecOut{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">rah::transform</a>(vecIn1, vecOut, [](<span class="keywordtype">int</span> a) {<span class="keywordflow">return</span> a + 1; });</div><div class="line">        assert(vecOut == std::vector&lt;int&gt;({ 1, 2, 3, 4 }));</div></div><!-- fragment -->
</div>
</div>
<a id="a7bac191e66e0d3f3823e0c08382f0418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bac191e66e0d3f3823e0c08382f0418">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RI1 , typename RI2 , typename RO , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto rah::transform </td>
          <td>(</td>
          <td class="paramtype">RI1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RI2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeIn2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RO &amp;&amp;&#160;</td>
          <td class="paramname"><em>rangeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary operation binary_op is applied to pairs of elements from two ranges. </p>
<div class="fragment"><div class="line">        std::vector&lt;int&gt; vecIn1{ 0, 1, 2, 3 };</div><div class="line">        std::vector&lt;int&gt; vecIn2{ 4, 3, 2, 1 };</div><div class="line">        std::vector&lt;int&gt; vecOut{ 0, 0, 0, 0 };</div><div class="line">        <a class="code" href="namespacerah.html#a7cb27bf7219a7ee4b47cc9da217810a8">rah::transform</a>(vecIn1, vecIn2, vecOut, [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {<span class="keywordflow">return</span> a + b; });</div><div class="line">        assert(vecOut == std::vector&lt;int&gt;({ 4, 4, 4, 4 }));</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
